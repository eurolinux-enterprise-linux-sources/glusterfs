From 2eb78b9118c0680b924dd6298265455126069456 Mon Sep 17 00:00:00 2001
From: Dan Lambright <dlambrig@redhat.com>
Date: Mon, 28 Dec 2015 10:13:30 -0500
Subject: [PATCH 227/237] cluster/tier: check watermark during migration

Currently we check the watermarks only before a cycle
begins. We should also check the hot tier's fullness
against the watermarks during the migration so the watermark
is not exceeded as files are promoted.

This is a backport of 13103

> Change-Id: I2ff87a1c308d64fbdca14bbdf55f3ec3007290ae
> BUG: 1293932
> Signed-off-by: Dan Lambright <dlambrig@redhat.com>
> Reviewed-on: http://review.gluster.org/13103
> Reviewed-by: Joseph Fernandes
> Tested-by: Gluster Build System <jenkins@build.gluster.com>
> Reviewed-by: N Balachandran <nbalacha@redhat.com>
Signed-off-by: Dan Lambright <dlambrig@redhat.com>

Change-Id: I6137b9f3a35740228ab7bb1f6007717116edb83a
BUG: 1291969
Reviewed-on: https://code.engineering.redhat.com/gerrit/64888
Reviewed-by: Dan Lambright <dlambrig@redhat.com>
Tested-by: Dan Lambright <dlambrig@redhat.com>
---
 xlators/cluster/dht/src/tier.c |  103 ++++++++++++++++++++++------------------
 1 files changed, 57 insertions(+), 46 deletions(-)

diff --git a/xlators/cluster/dht/src/tier.c b/xlators/cluster/dht/src/tier.c
index 9d9680d..6e031d5 100644
--- a/xlators/cluster/dht/src/tier.c
+++ b/xlators/cluster/dht/src/tier.c
@@ -83,51 +83,6 @@ out:
 }
 
 int
-tier_do_migration (xlator_t *this, int promote)
-{
-        gf_defrag_info_t       *defrag = NULL;
-        dht_conf_t             *conf   = NULL;
-        long                    rand = 0;
-        int                     migrate = 0;
-        gf_tier_conf_t         *tier_conf = NULL;
-
-        conf = this->private;
-        if (!conf)
-                goto exit;
-
-        defrag = conf->defrag;
-        if (!defrag)
-                goto exit;
-
-        if (defrag->tier_conf.mode != TIER_MODE_WM) {
-                migrate = 1;
-                goto exit;
-        }
-
-        tier_conf = &defrag->tier_conf;
-
-        switch (tier_conf->watermark_last) {
-        case TIER_WM_LOW:
-                migrate = promote ? 1 : 0;
-                break;
-        case TIER_WM_HI:
-                migrate = promote ? 0 : 1;
-                break;
-        case TIER_WM_MID:
-                rand = random() % 100;
-                if (promote) {
-                        migrate = (rand > tier_conf->percent_full);
-                } else {
-                        migrate = (rand <= tier_conf->percent_full);
-                }
-                break;
-        }
-
-exit:
-        return migrate;
-}
-
-int
 tier_check_watermark (xlator_t *this, loc_t *root_loc)
 {
         tier_watermark_op_t     wm = TIER_WM_NONE;
@@ -156,6 +111,7 @@ tier_check_watermark (xlator_t *this, loc_t *root_loc)
         /* Find how much free space is on the hot subvolume. Then see if that value */
         /* is less than or greater than user defined watermarks. Stash results in */
         /* the tier_conf data structure. */
+
         ret = syncop_statfs (conf->subvolumes[1], root_loc, &statfs,
                              xdata, NULL);
         if (ret) {
@@ -196,6 +152,59 @@ exit:
         return ret;
 }
 
+int
+tier_do_migration (xlator_t *this, int promote, loc_t *root_loc)
+{
+        gf_defrag_info_t       *defrag = NULL;
+        dht_conf_t             *conf   = NULL;
+        long                    rand = 0;
+        int                     migrate = 0;
+        gf_tier_conf_t         *tier_conf = NULL;
+
+        conf = this->private;
+        if (!conf)
+                goto exit;
+
+        defrag = conf->defrag;
+        if (!defrag)
+                goto exit;
+
+        if (defrag->tier_conf.mode != TIER_MODE_WM) {
+                migrate = 1;
+                goto exit;
+        }
+
+        if (tier_check_watermark (this, root_loc) != 0) {
+                gf_msg (this->name, GF_LOG_CRITICAL, errno,
+                        DHT_MSG_LOG_TIER_ERROR,
+                        "Failed to get watermark");
+                goto exit;
+        }
+
+        tier_conf = &defrag->tier_conf;
+
+        switch (tier_conf->watermark_last) {
+        case TIER_WM_LOW:
+                migrate = promote ? 1 : 0;
+                break;
+        case TIER_WM_HI:
+                migrate = promote ? 0 : 1;
+                break;
+        case TIER_WM_MID:
+                rand = random() % 100;
+                if (promote) {
+                        migrate = (rand > tier_conf->percent_full);
+                } else {
+                        migrate = (rand <= tier_conf->percent_full);
+                }
+                break;
+        }
+
+exit:
+        return migrate;
+}
+
+
 static int
 tier_migrate_using_query_file (void *_args)
 {
@@ -228,6 +237,7 @@ tier_migrate_using_query_file (void *_args)
         dht_conf_t   *conf                      = NULL;
         uint64_t total_migrated_bytes           = 0;
         int total_files                         = 0;
+        loc_t root_loc                          = { 0 };
 
         GF_VALIDATE_OR_GOTO ("tier", query_cbk_args, out);
         GF_VALIDATE_OR_GOTO ("tier", query_cbk_args->this, out);
@@ -263,6 +273,7 @@ tier_migrate_using_query_file (void *_args)
                 goto out;
         }
 
+        dht_build_root_loc (defrag->root_inode, &root_loc);
 
         /* Per file */
         while ((ret = gfdb_methods.gfdb_read_query_record
@@ -291,7 +302,7 @@ tier_migrate_using_query_file (void *_args)
                         break;
                 }
 
-                if (!tier_do_migration (this, query_cbk_args->is_promotion)) {
+                if (!tier_do_migration (this, query_cbk_args->is_promotion, &root_loc)) {
                         gfdb_methods.gfdb_query_record_free (query_record);
                         query_record = NULL;
                         continue;
-- 
1.7.1

