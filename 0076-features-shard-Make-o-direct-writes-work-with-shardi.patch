From cda89700fc54c391bfca23cbb0c68224ae3f576f Mon Sep 17 00:00:00 2001
From: Krutika Dhananjay <kdhananj@redhat.com>
Date: Tue, 29 Mar 2016 18:36:08 +0530
Subject: [PATCH 76/80] features/shard: Make o-direct writes work with sharding

        Backport of: http://review.gluster.org/#/c/13846/
        release-3.7 patch: http://review.gluster.org/#/c/13966/

With files opened with o-direct, the expectation is that
the IO performed on the fds is byte aligned wrt the sector size
of the underlying device. With files getting sharded, a single
write from the application could be broken into more than one write
falling on different shards which _might_ cause the original byte alignment
property to be lost. To get around this, shard translator will send fsync
on odirect writes to emulate o-direct-like behavior in the backend.

Change-Id: Ic0291cfca16902b9c35a123eb5f4f46924a09395
BUG: 1314421
Signed-off-by: Krutika Dhananjay <kdhananj@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/71872
Reviewed-by: Pranith Kumar Karampuri <pkarampu@redhat.com>
Tested-by: Pranith Kumar Karampuri <pkarampu@redhat.com>
---
 xlators/features/shard/src/shard.c |    6 ++++++
 1 files changed, 6 insertions(+), 0 deletions(-)

diff --git a/xlators/features/shard/src/shard.c b/xlators/features/shard/src/shard.c
index c7a57e0..78bb82d 100644
--- a/xlators/features/shard/src/shard.c
+++ b/xlators/features/shard/src/shard.c
@@ -3591,6 +3591,7 @@ shard_common_inode_write_do (call_frame_t *frame, xlator_t *this)
         shard_local_t  *local             = NULL;
         struct iovec   *vec               = NULL;
         gf_boolean_t    wind_failed       = _gf_false;
+        gf_boolean_t    odirect           = _gf_false;
         off_t           orig_offset       = 0;
         off_t           shard_offset      = 0;
         off_t           vec_offset        = 0;
@@ -3621,6 +3622,9 @@ shard_common_inode_write_do (call_frame_t *frame, xlator_t *this)
                 return 0;
         }
 
+        if ((fd->flags & O_DIRECT) && (local->fop == GF_FOP_WRITE))
+                odirect = _gf_true;
+
         while (cur_block <= last_block) {
                 if (wind_failed) {
                         shard_common_inode_write_do_cbk (frame,
@@ -3678,6 +3682,8 @@ shard_common_inode_write_do (call_frame_t *frame, xlator_t *this)
                                                                  NULL, NULL);
                                 goto next;
                         }
+                        if (odirect)
+                                local->flags |= O_SYNC;
                 }
 
                 shard_common_inode_write_wind (frame, this, anon_fd,
-- 
1.7.1

