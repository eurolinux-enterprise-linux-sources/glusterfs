From 2a2e373c9ebb3a46fd92c9c184c4b7375d5516da Mon Sep 17 00:00:00 2001
From: Joseph Fernandes <josferna@redhat.com>
Date: Fri, 18 Sep 2015 19:57:54 +0530
Subject: [PATCH 03/23] tier/ctr: Solution for db locks for tier migrator and ctr using sqlite version less than 3.7 i.e rhel 6.7

Problem: On RHEL 6.7, we have sqlite version 3.6.2 which doesnt support
WAL journaling mode, as this journaling mode is only available in sqlite 3.7 and above.
As a result we cannot have to progreses concurrently accessing sqlite, without
running into db locks! Well WAL is also need for performace on CTR side.

Solution: This solution is to use CTR db connection for doing queries when WAL mode is
absent. i,e tier migrator will send sync_op ipc calls to CTR, which in turn will
do the query and create/update the query file suggested by tier migrator.

Pending: Well this solution will stop the db locks but the performance is still an issue for CTR.
We are developing an in-Memory Transaction Log (iMeTaL) which will help boost the CTR
performance by doing in memory udpates on the IO path and later flush the updates to
the db in a batch/segment flush.

Backport of : http://review.gluster.org/#/c/12191/

>>Change-Id: Ie3149643ded159234b5cc6aa6cf93b9022c2f124
>>BUG: 1240577
>>Signed-off-by: Joseph Fernandes <josferna@redhat.com>
>>Signed-off-by: Dan Lambright <dlambrig@redhat.com>
>>Signed-off-by: Joseph Fernandes <josferna@redhat.com>
>>Reviewed-on: http://review.gluster.org/12191
>>Tested-by: Gluster Build System <jenkins@build.gluster.com>
>>Reviewed-by: Luis Pabon <lpabon@redhat.com>
Signed-off-by: Joseph Fernandes <josferna@redhat.com>

Change-Id: I21ea198c08bbbd226a11c274dd8d642df045af61
BUG: 1271729
Reviewed-on: https://code.engineering.redhat.com/gerrit/59395
Reviewed-by: Dan Lambright <dlambrig@redhat.com>
Tested-by: Dan Lambright <dlambrig@redhat.com>
---
 libglusterfs/src/gfdb/gfdb_data_store.c            |  109 ++++++--
 libglusterfs/src/gfdb/gfdb_data_store.h            |   90 +++++-
 libglusterfs/src/gfdb/gfdb_data_store_types.h      |   10 +
 libglusterfs/src/gfdb/gfdb_sqlite3.c               |  261 +++++++++++----
 libglusterfs/src/gfdb/gfdb_sqlite3.h               |   28 ++
 xlators/cluster/dht/src/dht-mem-types.h            |    1 +
 xlators/cluster/dht/src/dht-messages.h             |   11 +-
 xlators/cluster/dht/src/tier.c                     |  307 +++++++++++++++++-
 .../changetimerecorder/src/changetimerecorder.c    |  332 +++++++++++++++++---
 .../features/changetimerecorder/src/ctr-helper.h   |    7 +
 10 files changed, 1008 insertions(+), 148 deletions(-)

diff --git a/libglusterfs/src/gfdb/gfdb_data_store.c b/libglusterfs/src/gfdb/gfdb_data_store.c
index 5859a3d..937c7c6 100644
--- a/libglusterfs/src/gfdb/gfdb_data_store.c
+++ b/libglusterfs/src/gfdb/gfdb_data_store.c
@@ -236,7 +236,7 @@ init_db (dict_t *args, gfdb_db_type_t gfdb_db_type)
         if (!_conn_node) {
                 gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, ENOMEM,
                         LG_MSG_NO_MEMORY, "Failed mem alloc for "
-                        "gfdb_conn_node_t!");
+                        "gfdb_conn_node_t");
                 goto alloc_failed;
         }
 
@@ -384,7 +384,7 @@ insert_record (gfdb_conn_node_t *_conn_node,
                 if (ret) {
                         gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
                                 LG_MSG_INSERT_OR_UPDATE_FAILED, "Insert/Update"
-                                " operation failed!");
+                                " operation failed");
                 }
         }
 
@@ -424,7 +424,7 @@ delete_record (gfdb_conn_node_t *_conn_node,
                 if (ret) {
                         gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
                                 LG_MSG_DELETE_FAILED, "Delete operation "
-                                "failed!");
+                                "failed");
                 }
 
         }
@@ -464,7 +464,7 @@ find_all(gfdb_conn_node_t *_conn_node, gf_query_callback_t query_callback,
                 if (ret) {
                         gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
                                 LG_MSG_FIND_OP_FAILED, "Find all operation "
-                                "failed!");
+                                "failed");
                 }
 
         }
@@ -511,7 +511,7 @@ find_unchanged_for_time(gfdb_conn_node_t *_conn_node,
                 if (ret) {
                         gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
                                 LG_MSG_FIND_OP_FAILED, "Find unchanged "
-                                "operation failed!");
+                                "operation failed");
                 }
 
         }
@@ -556,7 +556,7 @@ find_recently_changed_files(gfdb_conn_node_t *_conn_node,
                 if (ret) {
                         gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
                                 LG_MSG_FIND_OP_FAILED,
-                                "Find changed operation failed!");
+                                "Find changed operation failed");
                 }
 
         }
@@ -613,7 +613,7 @@ find_unchanged_for_time_freq(gfdb_conn_node_t *_conn_node,
                 if (ret) {
                         gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
                                 LG_MSG_FIND_OP_FAILED,
-                                "Find unchanged with freq operation failed!");
+                                "Find unchanged with freq operation failed");
                 }
 
         }
@@ -669,7 +669,7 @@ find_recently_changed_files_freq(gfdb_conn_node_t *_conn_node,
                 if (ret) {
                         gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
                                 LG_MSG_FIND_OP_FAILED,
-                                "Find changed with freq operation failed!");
+                                "Find changed with freq operation failed");
                 }
 
         }
@@ -683,37 +683,102 @@ find_recently_changed_files_freq(gfdb_conn_node_t *_conn_node,
 /*Libgfdb API Function: Clear the heat for all the files
  *
  *  Arguments:
- *    _conn_node              : GFDB Connection node
+ *    conn_node              : GFDB Connection node
  *
  * Returns : if successful return 0 or
  *           -ve value in case of failure
  **/
 
 int
-clear_files_heat (gfdb_conn_node_t *_conn_node) {
+clear_files_heat (gfdb_conn_node_t *conn_node) {
         int ret = 0;
-        gfdb_db_operations_t *db_operations_t   = NULL;
+        gfdb_db_operations_t *db_operations   = NULL;
         void *gf_db_connection                  = NULL;
 
-        CHECK_CONN_NODE(_conn_node);
+        CHECK_CONN_NODE(conn_node);
 
-        db_operations_t = &_conn_node->gfdb_connection.gfdb_db_operations;
-        gf_db_connection = _conn_node->gfdb_connection.gf_db_connection;
+        db_operations = &conn_node->gfdb_connection.gfdb_db_operations;
+        gf_db_connection = conn_node->gfdb_connection.gf_db_connection;
 
-        if (db_operations_t->clear_files_heat_op) {
-                ret =  db_operations_t->clear_files_heat_op (gf_db_connection);
+        if (db_operations->clear_files_heat_op) {
+                ret =  db_operations->clear_files_heat_op (gf_db_connection);
                 if (ret) {
                         gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
                                 LG_MSG_FIND_OP_FAILED,
-                                "Clear files heat operation failed!");
+                                "Clear files heat operation failed");
+                }
+        }
+
+        return ret;
+}
+
+
+/* Libgfdb API Function: Function to extract version of the db
+ * Input:
+ * gfdb_conn_node_t *conn_node        : GFDB Connection node
+ * char **version  : the version is extracted as a string and will be stored in
+ *                   this variable. The freeing of the memory should be done by
+ *                   the caller.
+ * Return:
+ *      On success return the lenght of the version string that is
+ *      extracted.
+ *      On failure return -1
+ * */
+int
+get_db_version (gfdb_conn_node_t *conn_node, char **version)
+{
+        int ret = 0;
+        gfdb_db_operations_t *db_operations   = NULL;
+        void *gf_db_connection                  = NULL;
+
+        CHECK_CONN_NODE(conn_node);
+
+        db_operations = &conn_node->gfdb_connection.gfdb_db_operations;
+        gf_db_connection = conn_node->gfdb_connection.gf_db_connection;
+
+        if (db_operations->get_db_version) {
+                ret =  db_operations->get_db_version (gf_db_connection,
+                                                        version);
+                if (ret < 0) {
+                        gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
+                                LG_MSG_FIND_OP_FAILED,
+                                "Get version failed");
                 }
         }
 
         return ret;
 }
 
+int
+get_db_setting (gfdb_conn_node_t *conn_node, char *param_key,
+                char **param_value)
+{
+        int ret = -1;
+        gfdb_db_operations_t *db_operations   = NULL;
+        void *gf_db_connection                  = NULL;
+
+        CHECK_CONN_NODE(conn_node);
+
+        db_operations = &conn_node->gfdb_connection.gfdb_db_operations;
+        gf_db_connection = conn_node->gfdb_connection.gf_db_connection;
+
+        if (db_operations->get_db_setting) {
+                ret =  db_operations->get_db_setting (gf_db_connection,
+                                                        param_key, param_value);
+                if (ret < 0) {
+                        gf_msg (GFDB_DATA_STORE, GF_LOG_ERROR, 0,
+                                LG_MSG_FIND_OP_FAILED,
+                                "Get setting failed");
+                }
+        }
+
+        return ret;
+}
+
+
+
 static const
-char *get_db_path()
+char *get_db_path_key()
 {
         return GFDB_SQL_PARAM_DBPATH;
 }
@@ -725,6 +790,10 @@ void get_gfdb_methods (gfdb_methods_t *methods)
         methods->find_unchanged_for_time = find_unchanged_for_time;
         methods->find_recently_changed_files = find_recently_changed_files;
         methods->find_unchanged_for_time_freq = find_unchanged_for_time_freq;
-        methods->find_recently_changed_files_freq = find_recently_changed_files_freq;
-        methods->get_db_path = get_db_path;
+        methods->find_recently_changed_files_freq =
+                                               find_recently_changed_files_freq;
+        methods->clear_files_heat = clear_files_heat;
+        methods->get_db_version = get_db_version;
+        methods->get_db_setting = get_db_setting;
+        methods->get_db_path_key = get_db_path_key;
 }
diff --git a/libglusterfs/src/gfdb/gfdb_data_store.h b/libglusterfs/src/gfdb/gfdb_data_store.h
index 2eb7edf..9241170 100644
--- a/libglusterfs/src/gfdb/gfdb_data_store.h
+++ b/libglusterfs/src/gfdb/gfdb_data_store.h
@@ -25,6 +25,42 @@
 
 #include "gfdb_data_store_types.h"
 
+#define GFDB_IPC_CTR_KEY "gfdb.ipc-ctr-op"
+
+/*
+ * CTR IPC OPERATIONS
+ *
+ *
+ */
+#define GFDB_IPC_CTR_QUERY_OPS "gfdb.ipc-ctr-query-op"
+#define GFDB_IPC_CTR_CLEAR_OPS "gfdb.ipc-ctr-clear-op"
+#define GFDB_IPC_CTR_GET_DB_PARAM_OPS "gfdb.ipc-ctr-get-db-parm"
+#define GFDB_IPC_CTR_GET_DB_VERSION_OPS "gfdb.ipc-ctr-get-db-version"
+
+/*
+ * CTR IPC INPUT/OUTPUT
+ *
+ *
+ */
+#define GFDB_IPC_CTR_GET_QFILE_PATH "gfdb.ipc-ctr-get-qfile-path"
+#define GFDB_IPC_CTR_GET_QUERY_PARAMS "gfdb.ipc-ctr-get-query-parms"
+#define GFDB_IPC_CTR_RET_QUERY_COUNT "gfdb.ipc-ctr-ret-rec-count"
+#define GFDB_IPC_CTR_GET_DB_KEY "gfdb.ipc-ctr-get-params-key"
+#define GFDB_IPC_CTR_RET_DB_VERSION "gfdb.ipc-ctr-ret-db-version"
+
+/*
+ * gfdb ipc ctr params for query
+ *
+ *
+ */
+typedef struct gfdb_ipc_ctr_params {
+        gf_boolean_t is_promote;
+        int write_freq_threshold;
+        int read_freq_threshold;
+        gfdb_time_t time_stamp;
+} gfdb_ipc_ctr_params_t;
+
+
 /* GFDB Connection Node:
  * ~~~~~~~~~~~~~~~~~~~~
  * Represents the connection to the database while using libgfdb
@@ -171,7 +207,7 @@ typedef int (*find_recently_changed_files_t) (gfdb_conn_node_t *_conn_node,
 
 
 typedef const
-char * (*get_db_path_t) ();
+char * (*get_db_path_key_t) ();
 
 /*Libgfdb API Function: Query records/files that have not changed/accessed
  *                      from a time in past to current time, with
@@ -255,6 +291,51 @@ typedef int (*find_recently_changed_files_freq_t) (gfdb_conn_node_t *_conn_node,
 int
 clear_files_heat (gfdb_conn_node_t *_conn_node);
 
+typedef int (*clear_files_heat_t) (gfdb_conn_node_t *_conn_node);
+
+
+
+/* Libgfdb API Function: Function to extract version of the db
+ *  Arguments:
+ * gfdb_conn_node_t *_conn_node        : GFDB Connection node
+ * char **version  : the version is extracted as a string and will be stored in
+ *                   this variable. The freeing of the memory should be done by
+ *                   the caller.
+ * Return:
+ *      On success return the length of the version string that is
+ *      extracted.
+ *      On failure return -1
+ * */
+int
+get_db_version (gfdb_conn_node_t *_conn_node, char **version);
+
+typedef int (*get_db_version_t)(gfdb_conn_node_t *_conn_node,
+                                        char **version);
+
+
+/* Libgfdb API Function: Function to extract setting from the db
+ *  Arguments:
+ * gfdb_conn_node_t *_conn_node        : GFDB Connection node
+ * char *param_key     : setting to be extracted
+ * char **param_value  : the value of the setting that is
+ *                       extracted. This function will allocate memory
+ *                       to pragma_value. The caller should free the memory.
+ * Return:
+ *      On success return the lenght of the pragma/setting value that is
+ *      extracted.
+ *      On failure return -1
+ * */
+int
+get_db_setting (gfdb_conn_node_t *_conn_node,
+                char *param_key,
+                char **param_value);
+
+typedef int (*get_db_setting_t)(gfdb_conn_node_t *db_conn,
+                                     char *param_key,
+                                     char **param_value);
+
+
+
 typedef struct gfdb_methods_s {
         init_db_t init_db;
         fini_db_t fini_db;
@@ -262,8 +343,13 @@ typedef struct gfdb_methods_s {
         find_recently_changed_files_t find_recently_changed_files;
         find_unchanged_for_time_freq_t find_unchanged_for_time_freq;
         find_recently_changed_files_freq_t find_recently_changed_files_freq;
+        clear_files_heat_t clear_files_heat;
+        get_db_version_t get_db_version;
+        get_db_setting_t get_db_setting;
+        /* Do not expose dbpath directly. Expose it via an */
+        /* access function: get_db_path_key(). */
         char *dbpath;
-        get_db_path_t get_db_path;
+        get_db_path_key_t get_db_path_key;
 } gfdb_methods_t;
 
 void get_gfdb_methods (gfdb_methods_t *methods);
diff --git a/libglusterfs/src/gfdb/gfdb_data_store_types.h b/libglusterfs/src/gfdb/gfdb_data_store_types.h
index e21c480..4ad2bd4 100644
--- a/libglusterfs/src/gfdb/gfdb_data_store_types.h
+++ b/libglusterfs/src/gfdb/gfdb_data_store_types.h
@@ -656,6 +656,13 @@ typedef int
 
 typedef int (*gfdb_clear_files_heat_t)(void *db_conn);
 
+typedef int (*gfdb_get_db_version_t)(void *db_conn,
+                                        char **version);
+
+typedef int (*gfdb_get_db_setting_t)(void *db_conn,
+                                char *param_key,
+                                char **param_value);
+
 
 /*Data structure holding all the above plugin function pointers*/
 typedef struct gfdb_db_operations {
@@ -671,6 +678,8 @@ typedef struct gfdb_db_operations {
         gfdb_find_recently_changed_files_freq_t
                                         find_recently_changed_files_freq_op;
         gfdb_clear_files_heat_t clear_files_heat_op;
+        gfdb_get_db_version_t           get_db_version;
+        gfdb_get_db_setting_t           get_db_setting;
 } gfdb_db_operations_t;
 
 /*******************************************************************************
@@ -714,6 +723,7 @@ typedef struct gfdb_connection {
                         gf_msg (comp_name, GF_LOG_ERROR, 0,\
                                 LG_MSG_SET_PARAM_FAILED, "Failed setting %s "\
                                 "to params dictionary", param_key);\
+                        data_destroy (data);\
                         goto error;\
                 };\
         } while (0)
diff --git a/libglusterfs/src/gfdb/gfdb_sqlite3.c b/libglusterfs/src/gfdb/gfdb_sqlite3.c
index 40817af..224c6ba 100644
--- a/libglusterfs/src/gfdb/gfdb_sqlite3.c
+++ b/libglusterfs/src/gfdb/gfdb_sqlite3.c
@@ -69,17 +69,17 @@ gf_sql_str2jm (const char *jm_str)
 {
         if (!jm_str) {
                 return gf_sql_jm_invalid;
-        } else if (strcmp(jm_str, GF_SQL_JM_DELETE) == 0) {
+        } else if (strcmp (jm_str, GF_SQL_JM_DELETE) == 0) {
                 return gf_sql_jm_delete;
-        } else if (strcmp(jm_str, GF_SQL_JM_TRUNCATE) == 0) {
+        } else if (strcmp (jm_str, GF_SQL_JM_TRUNCATE) == 0) {
                 return gf_sql_jm_truncate;
-        } else if (strcmp(jm_str, GF_SQL_JM_PERSIST) == 0) {
+        } else if (strcmp (jm_str, GF_SQL_JM_PERSIST) == 0) {
                 return gf_sql_jm_persist;
-        } else if (strcmp(jm_str, GF_SQL_JM_MEMORY) == 0) {
+        } else if (strcmp (jm_str, GF_SQL_JM_MEMORY) == 0) {
                 return gf_sql_jm_memory;
-        } else if (strcmp(jm_str, GF_SQL_JM_WAL) == 0) {
+        } else if (strcmp (jm_str, GF_SQL_JM_WAL) == 0) {
                 return gf_sql_jm_wal;
-        } else if (strcmp(jm_str, GF_SQL_JM_OFF) == 0) {
+        } else if (strcmp (jm_str, GF_SQL_JM_OFF) == 0) {
                 return gf_sql_jm_off;
         }
         return gf_sql_jm_invalid;
@@ -106,11 +106,11 @@ gf_sql_str2av_t (const char *av_str)
 {
         if (!av_str) {
                 return gf_sql_sync_invalid;
-        } else if (strcmp(av_str, GF_SQL_AV_NONE) == 0) {
+        } else if (strcmp (av_str, GF_SQL_AV_NONE) == 0) {
                 return gf_sql_av_none;
-        } else if (strcmp(av_str, GF_SQL_AV_FULL) == 0) {
+        } else if (strcmp (av_str, GF_SQL_AV_FULL) == 0) {
                 return gf_sql_av_full;
-        } else if (strcmp(av_str, GF_SQL_AV_INCR) == 0) {
+        } else if (strcmp (av_str, GF_SQL_AV_INCR) == 0) {
                 return gf_sql_av_incr;
         }
         return gf_sql_sync_invalid;
@@ -137,11 +137,11 @@ gf_sql_str2sync_t (const char *sync_str)
 {
         if (!sync_str) {
                 return gf_sql_sync_invalid;
-        } else if (strcmp(sync_str, GF_SQL_SYNC_OFF) == 0) {
+        } else if (strcmp (sync_str, GF_SQL_SYNC_OFF) == 0) {
                 return gf_sql_sync_off;
-        } else if (strcmp(sync_str, GF_SQL_SYNC_NORMAL) == 0) {
+        } else if (strcmp (sync_str, GF_SQL_SYNC_NORMAL) == 0) {
                 return gf_sql_sync_normal;
-        } else if (strcmp(sync_str, GF_SQL_SYNC_FULL) == 0) {
+        } else if (strcmp (sync_str, GF_SQL_SYNC_FULL) == 0) {
                 return gf_sql_sync_full;
         }
         return gf_sql_sync_invalid;
@@ -188,11 +188,11 @@ gf_open_sqlite3_conn(char *sqlite3_db_path, int flags)
         GF_ASSERT (sqlite3_db_path);
 
         /*Creates DB if not created*/
-        ret = sqlite3_open_v2(sqlite3_db_path, &sqlite3_db_conn, flags, NULL);
+        ret = sqlite3_open_v2 (sqlite3_db_path, &sqlite3_db_conn, flags, NULL);
         if (ret) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0, LG_MSG_DB_ERROR,
                         "FATAL: Could open %s : %s",
-                        sqlite3_db_path, sqlite3_errmsg(sqlite3_db_conn));
+                        sqlite3_db_path, sqlite3_errmsg (sqlite3_db_conn));
         }
         return sqlite3_db_conn;
 }
@@ -210,7 +210,7 @@ gf_close_sqlite3_conn(sqlite3 *sqlite3_db_conn)
                         gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                                 LG_MSG_CONNECTION_ERROR, "FATAL: sqlite3 close"
                                 " connection failed %s",
-                                sqlite3_errmsg(sqlite3_db_conn));
+                                sqlite3_errmsg (sqlite3_db_conn));
                         ret = -1;
                         goto out;
                 }
@@ -250,6 +250,10 @@ gf_sqlite3_fill_db_operations(gfdb_db_operations_t  *gfdb_db_ops)
                         gf_sqlite3_find_recently_changed_files_freq;
 
         gfdb_db_ops->clear_files_heat_op = gf_sqlite3_clear_files_heat;
+
+        gfdb_db_ops->get_db_version = gf_sqlite3_version;
+
+        gfdb_db_ops->get_db_setting = gf_sqlite3_pragma;
 }
 
 
@@ -262,7 +266,7 @@ create_filetable (sqlite3 *sqlite3_db_conn)
 
         GF_ASSERT(sqlite3_db_conn);
 
-        sql_stmt = sql_stmt_init();
+        sql_stmt = sql_stmt_init ();
         if (!sql_stmt) {
                 ret = ENOMEM;
                 goto out;
@@ -306,7 +310,7 @@ apply_sql_params_db(gf_sql_connection_t *sql_conn, dict_t *param_dict)
         GET_DB_PARAM_FROM_DICT_DEFAULT(GFDB_STR_SQLITE3, param_dict,
                         GFDB_SQL_PARAM_PAGE_SIZE, temp_str,
                         GF_SQL_DEFAULT_PAGE_SIZE);
-        sql_conn->page_size = atoi(temp_str);
+        sql_conn->page_size = atoi (temp_str);
         /*Apply page_size on the sqlite db*/
         GF_SQLITE3_SET_PRAGMA(sqlite3_config_str, "page_size", "%zd",
                         sql_conn->page_size, ret, out);
@@ -320,7 +324,7 @@ apply_sql_params_db(gf_sql_connection_t *sql_conn, dict_t *param_dict)
         GET_DB_PARAM_FROM_DICT_DEFAULT(GFDB_STR_SQLITE3, param_dict,
                         GFDB_SQL_PARAM_CACHE_SIZE, temp_str,
                         GF_SQL_DEFAULT_CACHE_SIZE);
-        sql_conn->cache_size = atoi(temp_str);
+        sql_conn->cache_size = atoi (temp_str);
         /*Apply cache size on the sqlite db*/
         GF_SQLITE3_SET_PRAGMA(sqlite3_config_str, "cache_size", "%zd",
                         sql_conn->cache_size, ret, out);
@@ -407,7 +411,7 @@ gf_sqlite3_init (dict_t *args, void **db_conn) {
                 return 0;
         }
 
-        if (!sqlite3_threadsafe()) {
+        if (!sqlite3_threadsafe ()) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_NOT_MULTITHREAD_MODE,
                         "sqlite3 is not in multithreaded mode");
@@ -448,7 +452,7 @@ gf_sqlite3_init (dict_t *args, void **db_conn) {
 
 
         /*Apply sqlite3 params to database*/
-        ret = apply_sql_params_db(sql_conn, args);
+        ret = apply_sql_params_db (sql_conn, args);
         if (ret) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_SET_PARAM_FAILED, "Failed applying sql params"
@@ -489,7 +493,7 @@ gf_sqlite3_fini (void **db_conn)
 
         if (sql_conn) {
                 if (sql_conn->sqlite3_db_conn) {
-                        ret = gf_close_sqlite3_conn(sql_conn->sqlite3_db_conn);
+                        ret = gf_close_sqlite3_conn (sql_conn->sqlite3_db_conn);
                         if (ret) {
                                 /*Logging of error done in
                                  * gf_close_sqlite3_conn()*/
@@ -523,7 +527,7 @@ int gf_sqlite3_insert(void *db_conn, gfdb_db_record_t *gfdb_db_record)
 
         /*This is for debugging bug. Will be removed with a bug fix*/
         if ((GFDB_FOP_WIND == gfdb_db_record->gfdb_fop_path) &&
-            (strncmp(gfdb_db_record->file_path, "<gfid", 5) == 0)) {
+            (strncmp (gfdb_db_record->file_path, "<gfid", 5) == 0)) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0, LG_MSG_SKIP_PATH,
                         "Skip path <gfid fop=%d",
                         gfdb_db_record->gfdb_fop_type);
@@ -532,7 +536,7 @@ int gf_sqlite3_insert(void *db_conn, gfdb_db_record_t *gfdb_db_record)
 
         switch (gfdb_db_record->gfdb_fop_path) {
         case GFDB_FOP_WIND:
-                ret = gf_sql_insert_wind(sql_conn, gfdb_db_record);
+                ret = gf_sql_insert_wind (sql_conn, gfdb_db_record);
                 if (ret) {
                         gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                                 LG_MSG_INSERT_FAILED, "Failed wind insert");
@@ -549,7 +553,7 @@ int gf_sqlite3_insert(void *db_conn, gfdb_db_record_t *gfdb_db_record)
                 break;
 
         case GFDB_FOP_WDEL:
-                ret = gf_sql_update_delete_wind(sql_conn, gfdb_db_record);
+                ret = gf_sql_update_delete_wind (sql_conn, gfdb_db_record);
                 if (ret) {
                         gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                                 LG_MSG_UPDATE_FAILED, "Failed updating delete "
@@ -559,7 +563,7 @@ int gf_sqlite3_insert(void *db_conn, gfdb_db_record_t *gfdb_db_record)
                 break;
         case GFDB_FOP_UNDEL:
         case GFDB_FOP_UNDEL_ALL:
-                ret = gf_sql_delete_unwind(sql_conn, gfdb_db_record);
+                ret = gf_sql_delete_unwind (sql_conn, gfdb_db_record);
                 if (ret) {
                         gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                                 LG_MSG_DELETE_FAILED, "Failed deleting");
@@ -625,18 +629,18 @@ gf_sqlite3_find_all (void *db_conn, gf_query_callback_t query_callback,
                    "GF_FILE_TB.GF_ID = GF_FLINK_TB.GF_ID) from GF_FILE_TB ;";
 
 
-        ret = sqlite3_prepare(sql_conn->sqlite3_db_conn, query_str, -1,
+        ret = sqlite3_prepare (sql_conn->sqlite3_db_conn, query_str, -1,
                                 &prep_stmt, 0);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_PREPARE_FAILED, "Failed preparing statment %s :"
                         "%s", query_str,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
-        ret = gf_sql_query_function(prep_stmt, query_callback, query_cbk_args);
+        ret = gf_sql_query_function (prep_stmt, query_callback, query_cbk_args);
         if (ret) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0, LG_MSG_QUERY_FAILED,
                         "Failed Query %s", query_str);
@@ -645,7 +649,7 @@ gf_sqlite3_find_all (void *db_conn, gf_query_callback_t query_callback,
 
         ret = 0;
 out:
-        sqlite3_finalize(prep_stmt);
+        sqlite3_finalize (prep_stmt);
         return ret;
 }
 
@@ -685,43 +689,43 @@ gf_sqlite3_find_recently_changed_files(void *db_conn,
                 "((" GF_COL_TB_RWSEC " * " TOSTRING(GFDB_MICROSEC) " + "
                 GF_COL_TB_RWMSEC ") >= ?)";
 
-        from_time_usec = gfdb_time_2_usec(from_time);
+        from_time_usec = gfdb_time_2_usec (from_time);
 
-        ret = sqlite3_prepare(sql_conn->sqlite3_db_conn, query_str, -1,
-                                &prep_stmt, 0);
+        ret = sqlite3_prepare (sql_conn->sqlite3_db_conn, query_str, -1,
+                               &prep_stmt, 0);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_PREPARE_FAILED, "Failed preparing statment %s :"
                         " %s", query_str,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Bind write wind time*/
-        ret = sqlite3_bind_int64(prep_stmt, 1, from_time_usec);
+        ret = sqlite3_bind_int64 (prep_stmt, 1, from_time_usec);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding from_time_usec "
                         "%"PRIu64" : %s", from_time_usec,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Bind read wind time*/
-        ret = sqlite3_bind_int64(prep_stmt, 2, from_time_usec);
+        ret = sqlite3_bind_int64 (prep_stmt, 2, from_time_usec);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding from_time_usec "
                         "%"PRIu64" : %s ", from_time_usec,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Execute the query*/
-        ret = gf_sql_query_function(prep_stmt, query_callback, query_cbk_args);
+        ret = gf_sql_query_function (prep_stmt, query_callback, query_cbk_args);
         if (ret) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0, LG_MSG_QUERY_FAILED,
                         "Failed Query %s", query_str);
@@ -730,7 +734,7 @@ gf_sqlite3_find_recently_changed_files(void *db_conn,
 
         ret = 0;
 out:
-        sqlite3_finalize(prep_stmt);
+        sqlite3_finalize (prep_stmt);
         return ret;
 }
 
@@ -770,43 +774,43 @@ gf_sqlite3_find_unchanged_for_time (void *db_conn,
                 "((" GF_COL_TB_RWSEC " * " TOSTRING(GFDB_MICROSEC) " + "
                 GF_COL_TB_RWMSEC ") <= ?)";
 
-        for_time_usec = gfdb_time_2_usec(for_time);
+        for_time_usec = gfdb_time_2_usec (for_time);
 
-        ret = sqlite3_prepare(sql_conn->sqlite3_db_conn, query_str, -1,
-                                &prep_stmt, 0);
+        ret = sqlite3_prepare (sql_conn->sqlite3_db_conn, query_str, -1,
+                               &prep_stmt, 0);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_PREPARE_FAILED, "Failed preparing statment %s :"
                         " %s", query_str,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Bind write wind time*/
-        ret = sqlite3_bind_int64(prep_stmt, 1, for_time_usec);
+        ret = sqlite3_bind_int64 (prep_stmt, 1, for_time_usec);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding for_time_usec "
                         "%"PRIu64" : %s", for_time_usec,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Bind read wind time*/
-        ret = sqlite3_bind_int64(prep_stmt, 2, for_time_usec);
+        ret = sqlite3_bind_int64 (prep_stmt, 2, for_time_usec);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding for_time_usec "
                         "%"PRIu64" : %s", for_time_usec,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Execute the query*/
-        ret = gf_sql_query_function(prep_stmt, query_callback, query_cbk_args);
+        ret = gf_sql_query_function (prep_stmt, query_callback, query_cbk_args);
         if (ret) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0, LG_MSG_QUERY_FAILED,
                         "Failed Query %s", query_str);
@@ -815,7 +819,7 @@ gf_sqlite3_find_unchanged_for_time (void *db_conn,
 
         ret = 0;
 out:
-        sqlite3_finalize(prep_stmt);
+        sqlite3_finalize (prep_stmt);
         return ret;
 }
 
@@ -867,66 +871,66 @@ gf_sqlite3_find_recently_changed_files_freq (void *db_conn,
                 GF_COL_TB_RWMSEC ") >= ?)"
                 " AND "" (" GF_COL_TB_RFC " >= ? ) )";
 
-        from_time_usec = gfdb_time_2_usec(from_time);
+        from_time_usec = gfdb_time_2_usec (from_time);
 
-        ret = sqlite3_prepare(sql_conn->sqlite3_db_conn, query_str, -1,
+        ret = sqlite3_prepare (sql_conn->sqlite3_db_conn, query_str, -1,
                                 &prep_stmt, 0);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_PREPARE_FAILED, "Failed preparing statment %s :"
                         " %s", query_str,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Bind write wind time*/
-        ret = sqlite3_bind_int64(prep_stmt, 1, from_time_usec);
+        ret = sqlite3_bind_int64 (prep_stmt, 1, from_time_usec);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding from_time_usec "
                         "%"PRIu64" : %s", from_time_usec,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Bind write frequency thresold*/
-        ret = sqlite3_bind_int(prep_stmt, 2, freq_write_cnt);
+        ret = sqlite3_bind_int (prep_stmt, 2, freq_write_cnt);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding freq_write_cnt "
                         "%d : %s", freq_write_cnt,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
 
         /*Bind read wind time*/
-        ret = sqlite3_bind_int64(prep_stmt, 3, from_time_usec);
+        ret = sqlite3_bind_int64 (prep_stmt, 3, from_time_usec);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding from_time_usec "
                         "%"PRIu64" : %s", from_time_usec,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Bind read frequency thresold*/
-        ret = sqlite3_bind_int(prep_stmt, 4, freq_read_cnt);
+        ret = sqlite3_bind_int (prep_stmt, 4, freq_read_cnt);
         if (ret != SQLITE_OK) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding freq_read_cnt "
                         "%d : %s", freq_read_cnt,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
 
         /*Execute the query*/
-        ret = gf_sql_query_function(prep_stmt, query_callback, query_cbk_args);
+        ret = gf_sql_query_function (prep_stmt, query_callback, query_cbk_args);
         if (ret) {
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0, LG_MSG_QUERY_FAILED,
                         "Failed Query %s", query_str);
@@ -937,7 +941,7 @@ gf_sqlite3_find_recently_changed_files_freq (void *db_conn,
 
         /*Clear counters*/
         if (clear_counters) {
-                ret = gf_sql_clear_counters(sql_conn);
+                ret = gf_sql_clear_counters (sql_conn);
                 if (ret) {
                         gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                                 LG_MSG_CLEAR_COUNTER_FAILED, "Failed clearing"
@@ -1012,7 +1016,7 @@ gf_sqlite3_find_unchanged_for_time_freq (void *db_conn,
                 GF_COL_TB_RWMSEC ") >= ? ) ) )";
 
 
-        for_time_usec = gfdb_time_2_usec(for_time);
+        for_time_usec = gfdb_time_2_usec (for_time);
 
         ret = sqlite3_prepare (sql_conn->sqlite3_db_conn, query_str, -1,
                                 &prep_stmt, 0);
@@ -1020,7 +1024,7 @@ gf_sqlite3_find_unchanged_for_time_freq (void *db_conn,
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_PREPARE_FAILED, "Failed preparing delete "
                         "statment %s : %s", query_str,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
@@ -1031,7 +1035,7 @@ gf_sqlite3_find_unchanged_for_time_freq (void *db_conn,
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding for_time_usec "
                         "%"PRIu64" : %s", for_time_usec,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
@@ -1042,7 +1046,7 @@ gf_sqlite3_find_unchanged_for_time_freq (void *db_conn,
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding freq_write_cnt"
                         " %d : %s", freq_write_cnt,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
@@ -1053,7 +1057,7 @@ gf_sqlite3_find_unchanged_for_time_freq (void *db_conn,
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding for_time_usec "
                         "%"PRIu64" : %s", for_time_usec,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
@@ -1066,7 +1070,7 @@ gf_sqlite3_find_unchanged_for_time_freq (void *db_conn,
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding for_time_usec "
                         "%"PRIu64" : %s", for_time_usec,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
@@ -1077,7 +1081,7 @@ gf_sqlite3_find_unchanged_for_time_freq (void *db_conn,
                 gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
                         LG_MSG_BINDING_FAILED, "Failed binding freq_read_cnt "
                         "%d : %s", freq_read_cnt,
-                        sqlite3_errmsg(sql_conn->sqlite3_db_conn));
+                        sqlite3_errmsg (sql_conn->sqlite3_db_conn));
                 ret = -1;
                 goto out;
         }
@@ -1115,7 +1119,7 @@ gf_sqlite3_find_unchanged_for_time_freq (void *db_conn,
 
         ret = 0;
 out:
-        sqlite3_finalize(prep_stmt);
+        sqlite3_finalize (prep_stmt);
         return ret;
 }
 
@@ -1141,3 +1145,120 @@ out:
         return ret;
 }
 
+
+/* Function to extract version of sqlite db
+ * Input:
+ * void *db_conn        : Sqlite connection
+ * char **version  : the version is extracted as a string and will be stored in
+ *                   this variable. The freeing of the memory should be done by
+ *                   the caller.
+ * Return:
+ *      On success return the lenght of the version string that is
+ *      extracted.
+ *      On failure return -1
+ * */
+int
+gf_sqlite3_version (void *db_conn, char **version)
+{
+        int ret = -1;
+        gf_sql_connection_t *sql_conn           =       db_conn;
+        sqlite3_stmt *pre_stmt = NULL;
+
+        CHECK_SQL_CONN (sql_conn, out);
+
+        ret = sqlite3_prepare_v2 (sql_conn->sqlite3_db_conn,
+                                "SELECT SQLITE_VERSION()",
+                                -1, &pre_stmt, 0);
+        if (ret != SQLITE_OK) {
+                gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
+                        LG_MSG_PREPARE_FAILED, "Failed init prepare stmt %s",
+                        sqlite3_errmsg (db_conn));
+                ret = -1;
+                goto out;
+        }
+
+        ret = sqlite3_step(pre_stmt);
+        if (ret != SQLITE_ROW) {
+                gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
+                        LG_MSG_GET_RECORD_FAILED, "Failed to get records "
+                        "from db : %s", sqlite3_errmsg (db_conn));
+                ret = -1;
+                goto out;
+        }
+
+        ret = gf_asprintf (version, "%s", sqlite3_column_text (pre_stmt, 0));
+        if (ret <= 0) {
+                gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0, LG_MSG_QUERY_FAILED,
+                        "Failed extracting version");
+        }
+
+out:
+        sqlite3_finalize (pre_stmt);
+
+        return ret;
+}
+
+
+
+/* Function to extract PRAGMA or setting from sqlite db
+ * Input:
+ * void *db_conn        : Sqlite connection
+ * char *pragma_key     : PRAGMA or setting to be extracted
+ * char **pragma_value  : the value of the PRAGMA or setting that is
+ *                        extracted. This function will allocate memory
+ *                        to pragma_value. The caller should free the memory
+ * Return:
+ *      On success return the lenght of the pragma/setting value that is
+ *      extracted.
+ *      On failure return -1
+ * */
+int
+gf_sqlite3_pragma (void *db_conn, char *pragma_key, char **pragma_value)
+{
+        int ret = -1;
+        gf_sql_connection_t *sql_conn = db_conn;
+        sqlite3_stmt *pre_stmt = NULL;
+        char *sqlstring = NULL;
+
+        CHECK_SQL_CONN (sql_conn, out);
+        GF_VALIDATE_OR_GOTO (GFDB_STR_SQLITE3, pragma_key, out);
+
+        ret = gf_asprintf (&sqlstring, "PRAGMA %s;", pragma_key);
+        if (ret <= 0) {
+                gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
+                        LG_MSG_PREPARE_FAILED, "Failed allocating memory");
+                goto out;
+        }
+
+        ret = sqlite3_prepare_v2 (sql_conn->sqlite3_db_conn,
+                                  sqlstring, -1, &pre_stmt, 0);
+        if (ret != SQLITE_OK) {
+                gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
+                        LG_MSG_PREPARE_FAILED, "Failed init prepare stmt %s",
+                        sqlite3_errmsg (db_conn));
+                ret = -1;
+                goto out;
+        }
+
+        ret = sqlite3_step (pre_stmt);
+        if (ret != SQLITE_ROW) {
+                gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0,
+                        LG_MSG_GET_RECORD_FAILED, "Failed to get records "
+                        "from db : %s", sqlite3_errmsg (db_conn));
+                ret = -1;
+                goto out;
+        }
+
+        ret = gf_asprintf (pragma_value, "%s", sqlite3_column_text (pre_stmt, 0));
+        if (ret <= 0) {
+                gf_msg (GFDB_STR_SQLITE3, GF_LOG_ERROR, 0, LG_MSG_QUERY_FAILED,
+                        "Failed to get version");
+        }
+
+out:
+        GF_FREE (sqlstring);
+
+        sqlite3_finalize (pre_stmt);
+
+        return ret;
+}
diff --git a/libglusterfs/src/gfdb/gfdb_sqlite3.h b/libglusterfs/src/gfdb/gfdb_sqlite3.h
index 34235e0..5c25938 100644
--- a/libglusterfs/src/gfdb/gfdb_sqlite3.h
+++ b/libglusterfs/src/gfdb/gfdb_sqlite3.h
@@ -286,6 +286,34 @@ int gf_sqlite3_find_recently_changed_files_freq (void *db_conn,
 
 int gf_sqlite3_clear_files_heat (void *db_conn);
 
+/* Function to extract version of sqlite db
+ * Input:
+ * void *db_conn        : Sqlite connection
+ * char **version  : the version is extracted as a string and will be stored in
+ *                   this variable. The freeing of the memory should be done by
+ *                   the caller.
+ * Return:
+ *      On success return the lenght of the version string that is
+ *      extracted.
+ *      On failure return -1
+ * */
+int gf_sqlite3_version (void *db_conn, char **version);
+
+/* Function to extract PRAGMA or setting from sqlite db
+ * Input:
+ * void *db_conn        : Sqlite connection
+ * char *pragma_key     : PRAGMA or setting to be extracted
+ * char **pragma_value  : the value of the PRAGMA or setting that is
+ *                        extracted. This function will allocate memory
+ *                        to pragma_value. The caller should free the memory
+ * Return:
+ *      On success return the lenght of the pragma/setting value that is
+ *      extracted.
+ *      On failure return -1
+ * */
+int gf_sqlite3_pragma (void *db_conn, char *pragma_key, char **pragma_value);
+
 void gf_sqlite3_fill_db_operations (gfdb_db_operations_t  *gfdb_db_ops);
 
+
 #endif
diff --git a/xlators/cluster/dht/src/dht-mem-types.h b/xlators/cluster/dht/src/dht-mem-types.h
index e3a38ed..a90b571 100644
--- a/xlators/cluster/dht/src/dht-mem-types.h
+++ b/xlators/cluster/dht/src/dht-mem-types.h
@@ -35,6 +35,7 @@ enum gf_dht_mem_types_ {
         gf_dht_mt_octx_t,
         gf_dht_mt_miginfo_t,
         gf_tier_mt_bricklist_t,
+        gf_tier_mt_ipc_ctr_params_t,
         gf_dht_mt_end
 };
 #endif
diff --git a/xlators/cluster/dht/src/dht-messages.h b/xlators/cluster/dht/src/dht-messages.h
index d6300d3..c491600 100644
--- a/xlators/cluster/dht/src/dht-messages.h
+++ b/xlators/cluster/dht/src/dht-messages.h
@@ -45,7 +45,7 @@
  */
 
 #define GLFS_DHT_BASE                   GLFS_MSGID_COMP_DHT
-#define GLFS_DHT_NUM_MESSAGES           106
+#define GLFS_DHT_NUM_MESSAGES           107
 #define GLFS_MSGID_END          (GLFS_DHT_BASE + GLFS_DHT_NUM_MESSAGES + 1)
 
 /* Messages with message IDs */
@@ -998,5 +998,14 @@
  */
 
 #define DHT_MSG_HAS_MIGINFO             (GLFS_DHT_BASE + 106)
+
+/*
+ * @messageid 109107
+ * @diagnosis
+ * @recommendedaction None
+ */
+
+#define DHT_MSG_LOG_IPC_TIER_ERROR      (GLFS_DHT_BASE + 107)
+
 #define glfs_msg_end_x GLFS_MSGID_END, "Invalid: End of messages"
 #endif /* _DHT_MESSAGES_H_ */
diff --git a/xlators/cluster/dht/src/tier.c b/xlators/cluster/dht/src/tier.c
index 327fceb..a592382 100644
--- a/xlators/cluster/dht/src/tier.c
+++ b/xlators/cluster/dht/src/tier.c
@@ -434,17 +434,20 @@ out:
         return ret;
 }
 
-/*This is the call back function for each brick from hot/cold bricklist
- * It picks up each bricks db and queries for eligible files for migration.
- * The list of eligible files are populated in appropriate query files*/
+
+
+
+/*Create query file in tier process*/
 static int
-tier_process_brick_cbk (brick_list_t *local_brick, void *args) {
+tier_process_self_query (brick_list_t *local_brick, void *args)
+{
         int ret                                         = -1;
         char *db_path                                   = NULL;
-        query_cbk_args_t *query_cbk_args              	= NULL;
+        query_cbk_args_t *query_cbk_args                = NULL;
         xlator_t *this                                  = NULL;
-        gfdb_conn_node_t *conn_node                   	= NULL;
+        gfdb_conn_node_t *conn_node                     = NULL;
         dict_t *params_dict                             = NULL;
+        dict_t *ctr_ipc_dict                            = NULL;
         _gfdb_brick_dict_info_t *gfdb_brick_dict_info   = args;
 
         /*Init of all the essentials*/
@@ -462,6 +465,7 @@ tier_process_brick_cbk (brick_list_t *local_brick, void *args) {
         GF_VALIDATE_OR_GOTO (this->name, local_brick->xlator, out);
 
         GF_VALIDATE_OR_GOTO (this->name, local_brick->brick_db_path, out);
+
         db_path = local_brick->brick_db_path;
 
         /*Preparing DB parameters before init_db i.e getting db connection*/
@@ -469,10 +473,10 @@ tier_process_brick_cbk (brick_list_t *local_brick, void *args) {
         if (!params_dict) {
                 gf_msg (this->name, GF_LOG_ERROR, 0,
                         DHT_MSG_LOG_TIER_ERROR,
-                        "DB Params cannot initialized!");
+                        "DB Params cannot initialized");
                 goto out;
         }
-        SET_DB_PARAM_TO_DICT(this->name, params_dict, (char *) gfdb_methods.get_db_path(),
+        SET_DB_PARAM_TO_DICT(this->name, params_dict, (char *) gfdb_methods.get_db_path_key(),
                                 db_path, ret, out);
 
         /*Get the db connection*/
@@ -543,17 +547,41 @@ tier_process_brick_cbk (brick_list_t *local_brick, void *args) {
         }
 
         /*Clear the heat on the DB entries*/
-        ret = syncop_ipc (local_brick->xlator, GF_IPC_TARGET_CTR, NULL, NULL);
+        /*Preparing ctr_ipc_dict*/
+        ctr_ipc_dict = dict_new ();
+        if (!ctr_ipc_dict) {
+                gf_msg (this->name, GF_LOG_ERROR, 0,
+                        DHT_MSG_LOG_TIER_ERROR,
+                        "ctr_ipc_dict cannot initialized");
+                goto out;
+        }
+
+        SET_DB_PARAM_TO_DICT(this->name, ctr_ipc_dict,
+                             GFDB_IPC_CTR_KEY, GFDB_IPC_CTR_CLEAR_OPS,
+                             ret, out);
+
+        ret = syncop_ipc (local_brick->xlator, GF_IPC_TARGET_CTR, ctr_ipc_dict,
+                                                                        NULL);
         if (ret) {
                 gf_msg (this->name, GF_LOG_ERROR, 0,
                         DHT_MSG_LOG_TIER_ERROR, "Failed clearing the heat "
-                        "on db %s", local_brick->brick_db_path);
+                        "on db %s error %d", local_brick->brick_db_path, ret);
                 goto out;
         }
 
         ret = 0;
 out:
-        if (query_cbk_args->queryFILE) {
+        if (params_dict) {
+                dict_unref (params_dict);
+                params_dict = NULL;
+        }
+
+        if (ctr_ipc_dict) {
+                dict_unref (ctr_ipc_dict);
+                ctr_ipc_dict = NULL;
+        }
+
+        if (query_cbk_args && query_cbk_args->queryFILE) {
                 fclose (query_cbk_args->queryFILE);
                 query_cbk_args->queryFILE = NULL;
         }
@@ -561,7 +589,246 @@ out:
         return ret;
 }
 
-static inline int
+
+
+
+
+/*Ask CTR to create the query file*/
+static int
+tier_process_ctr_query (brick_list_t *local_brick, void *args)
+{
+        int ret                                         = -1;
+        query_cbk_args_t *query_cbk_args                = NULL;
+        xlator_t *this                                  = NULL;
+        dict_t *ctr_ipc_in_dict                         = NULL;
+        dict_t *ctr_ipc_out_dict                        = NULL;
+        _gfdb_brick_dict_info_t *gfdb_brick_dict_info   = args;
+        gfdb_ipc_ctr_params_t *ipc_ctr_params           = NULL;
+        int count                                       = 0;
+
+        /*Init of all the essentials*/
+        GF_VALIDATE_OR_GOTO ("tier", gfdb_brick_dict_info , out);
+        query_cbk_args = gfdb_brick_dict_info->_query_cbk_args;
+
+        GF_VALIDATE_OR_GOTO ("tier", query_cbk_args->this, out);
+        this = query_cbk_args->this;
+
+        GF_VALIDATE_OR_GOTO (this->name,
+                             gfdb_brick_dict_info->_query_cbk_args, out);
+
+        GF_VALIDATE_OR_GOTO (this->name, local_brick, out);
+
+        GF_VALIDATE_OR_GOTO (this->name, local_brick->xlator, out);
+
+        GF_VALIDATE_OR_GOTO (this->name, local_brick->brick_db_path, out);
+
+
+        /*Preparing ctr_ipc_in_dict*/
+        ctr_ipc_in_dict = dict_new ();
+        if (!ctr_ipc_in_dict) {
+                gf_msg (this->name, GF_LOG_ERROR, 0,
+                        DHT_MSG_LOG_TIER_ERROR,
+                        "ctr_ipc_in_dict cannot initialized");
+                goto out;
+        }
+
+        ipc_ctr_params = GF_CALLOC (1, sizeof (gfdb_ipc_ctr_params_t),
+                                        gf_tier_mt_ipc_ctr_params_t);
+        if (!ipc_ctr_params) {
+                goto out;
+        }
+
+        /* set all the query params*/
+        ipc_ctr_params->is_promote = gfdb_brick_dict_info->_gfdb_promote;
+        ipc_ctr_params->write_freq_threshold = query_cbk_args->
+                                                defrag->write_freq_threshold;
+        ipc_ctr_params->read_freq_threshold = query_cbk_args->
+                                                defrag->read_freq_threshold;
+        memcpy (&ipc_ctr_params->time_stamp,
+                gfdb_brick_dict_info->time_stamp,
+                sizeof (gfdb_time_t));
+
+        SET_DB_PARAM_TO_DICT(this->name, ctr_ipc_in_dict,
+                             GFDB_IPC_CTR_KEY, GFDB_IPC_CTR_QUERY_OPS,
+                             ret, out);
+
+        SET_DB_PARAM_TO_DICT(this->name, ctr_ipc_in_dict,
+                             GFDB_IPC_CTR_GET_QFILE_PATH,
+                             GET_QFILE_PATH(ipc_ctr_params->is_promote),
+                             ret, out);
+
+        ret = dict_set_bin (ctr_ipc_in_dict, GFDB_IPC_CTR_GET_QUERY_PARAMS,
+                                ipc_ctr_params, sizeof (*ipc_ctr_params));
+        if (ret) {
+                gf_msg (this->name, GF_LOG_ERROR, 0, LG_MSG_SET_PARAM_FAILED,
+                        "Failed setting %s to params dictionary",
+                        GFDB_IPC_CTR_GET_QUERY_PARAMS);
+                goto out;
+        }
+
+        ret = syncop_ipc (local_brick->xlator, GF_IPC_TARGET_CTR,
+                                ctr_ipc_in_dict, &ctr_ipc_out_dict);
+        if (ret) {
+                gf_msg (this->name, GF_LOG_ERROR, 0,
+                        DHT_MSG_LOG_IPC_TIER_ERROR, "Failed query on %s ret %d",
+                        local_brick->brick_db_path, ret);
+                goto out;
+        }
+
+        ret = dict_get_int32(ctr_ipc_out_dict, GFDB_IPC_CTR_RET_QUERY_COUNT,
+                                &count);
+        if (ret) {
+                gf_msg (this->name, GF_LOG_ERROR, 0,
+                        DHT_MSG_LOG_TIER_ERROR, "Failed getting count "
+                        "of records on %s",
+                        local_brick->brick_db_path);
+                goto out;
+        }
+
+        if (count < 0) {
+                gf_msg (this->name, GF_LOG_ERROR, 0,
+                        DHT_MSG_LOG_TIER_ERROR, "Failed query on %s",
+                        local_brick->brick_db_path);
+                ret = -1;
+                goto out;
+        }
+
+        pthread_mutex_lock (&dm_stat_mutex);
+        query_cbk_args->defrag->num_files_lookedup = count;
+        pthread_mutex_unlock (&dm_stat_mutex);
+
+        ret = 0;
+out:
+
+        if (ctr_ipc_in_dict) {
+                dict_unref(ctr_ipc_in_dict);
+                ctr_ipc_in_dict = NULL;
+        }
+
+        if (ctr_ipc_out_dict) {
+                dict_unref(ctr_ipc_out_dict);
+                ctr_ipc_out_dict = NULL;
+                ipc_ctr_params = NULL;
+        }
+
+        GF_FREE (ipc_ctr_params);
+
+        return ret;
+}
+
+
+
+
+/*This is the call back function for each brick from hot/cold bricklist
+ * It picks up each bricks db and queries for eligible files for migration.
+ * The list of eligible files are populated in appropriate query files*/
+static int
+tier_process_brick (brick_list_t *local_brick, void *args) {
+        int ret = -1;
+        dict_t *ctr_ipc_in_dict = NULL;
+        dict_t *ctr_ipc_out_dict = NULL;
+        char *strval = NULL;
+
+        GF_VALIDATE_OR_GOTO ("tier", local_brick, out);
+
+        GF_VALIDATE_OR_GOTO ("tier", local_brick->xlator, out);
+
+        if (dht_tier_db_type == GFDB_SQLITE3) {
+
+                /*Preparing ctr_ipc_in_dict*/
+                ctr_ipc_in_dict = dict_new ();
+                if (!ctr_ipc_in_dict) {
+                        gf_msg ("tier", GF_LOG_ERROR, 0,
+                                DHT_MSG_LOG_TIER_ERROR,
+                                "ctr_ipc_in_dict cannot initialized");
+                        goto out;
+                }
+
+                ret = dict_set_str (ctr_ipc_in_dict, GFDB_IPC_CTR_KEY,
+                                                GFDB_IPC_CTR_GET_DB_PARAM_OPS);
+                if (ret) {
+                        gf_msg ("tier", GF_LOG_ERROR, 0,\
+                                LG_MSG_SET_PARAM_FAILED, "Failed setting %s "\
+                                "to params dictionary", GFDB_IPC_CTR_KEY);\
+                        goto out;
+                }
+
+                ret = dict_set_str (ctr_ipc_in_dict,
+                                GFDB_IPC_CTR_GET_DB_PARAM_OPS, "");
+                if (ret) {
+                        gf_msg ("tier", GF_LOG_ERROR, 0,\
+                                LG_MSG_SET_PARAM_FAILED, "Failed setting %s "\
+                                "to params dictionary",
+                                GFDB_IPC_CTR_GET_DB_PARAM_OPS);\
+                        goto out;
+                }
+
+                ret = dict_set_str (ctr_ipc_in_dict,
+                                GFDB_IPC_CTR_GET_DB_KEY, "journal_mode");
+                if (ret) {
+                        gf_msg ("tier", GF_LOG_ERROR, 0,\
+                                LG_MSG_SET_PARAM_FAILED, "Failed setting %s "\
+                                "to params dictionary",
+                                GFDB_IPC_CTR_GET_DB_KEY);\
+                        goto out;
+                }
+
+
+
+                ret = syncop_ipc (local_brick->xlator, GF_IPC_TARGET_CTR,
+                                ctr_ipc_in_dict, &ctr_ipc_out_dict);
+                if (ret || ctr_ipc_out_dict == NULL) {
+                        gf_msg ("tier", GF_LOG_ERROR, 0,
+                                DHT_MSG_LOG_TIER_ERROR, "Failed getting"
+                                "journal_mode of sql db %s",
+                                local_brick->brick_db_path);
+                        goto out;
+                }
+
+                ret = dict_get_str (ctr_ipc_out_dict, "journal_mode", &strval);
+                if (ret) {
+                        gf_msg ("tier", GF_LOG_ERROR, 0,\
+                                LG_MSG_GET_PARAM_FAILED, "Failed getting %s "\
+                                "to params dictionary",
+                                "journal_mode");\
+                        goto out;
+                }
+
+                if (strval && (strncmp(strval, "wal", strlen ("wal")) == 0)) {
+                        ret = tier_process_self_query (local_brick, args);
+                        if (ret) {
+                                goto out;
+                        }
+                } else {
+                        ret = tier_process_ctr_query (local_brick, args);
+                        if (ret) {
+                                goto out;
+                        }
+                }
+                ret = 0;
+
+        } else {
+                ret = tier_process_self_query (local_brick, args);
+                if (ret) {
+                        goto out;
+                }
+        }
+
+        ret = 0;
+out:
+        if  (ctr_ipc_in_dict)
+                dict_unref (ctr_ipc_in_dict);
+
+        if  (ctr_ipc_out_dict)
+                dict_unref (ctr_ipc_out_dict);
+
+        return ret;
+}
+
+
+
+
+static int
 tier_build_migration_qfile (demotion_args_t *args,
                             query_cbk_args_t *query_cbk_args,
                             gf_boolean_t is_promotion)
@@ -603,8 +870,8 @@ tier_build_migration_qfile (demotion_args_t *args,
         gfdb_brick_dict_info._query_cbk_args = query_cbk_args;
 
         list_for_each_entry (local_brick, args->brick_list, list) {
-                ret = tier_process_brick_cbk (local_brick,
-                                                &gfdb_brick_dict_info);
+                ret = tier_process_brick (local_brick,
+                                          &gfdb_brick_dict_info);
                 if (ret) {
                         gf_msg (args->this->name, GF_LOG_ERROR, 0,
                                 DHT_MSG_BRICK_QUERY_FAILED,
@@ -658,6 +925,8 @@ tier_demote (void *args)
         GF_VALIDATE_OR_GOTO (demotion_args->this->name,
                              demotion_args->defrag, out);
 
+        THIS = demotion_args->this;
+
         query_cbk_args.this = demotion_args->this;
         query_cbk_args.defrag = demotion_args->defrag;
         query_cbk_args.is_promotion = 0;
@@ -694,6 +963,8 @@ static void
         GF_VALIDATE_OR_GOTO (promotion_args->this->name,
                              promotion_args->defrag, out);
 
+        THIS = promotion_args->this;
+
         query_cbk_args.this = promotion_args->this;
         query_cbk_args.defrag = promotion_args->defrag;
         query_cbk_args.is_promotion = 1;
@@ -923,7 +1194,7 @@ tier_start (xlator_t *this, gf_defrag_info_t *defrag)
                                 gf_msg (this->name, GF_LOG_ERROR, 0,
                                         DHT_MSG_LOG_TIER_ERROR,
                                         "Failed starting Demotion "
-                                        "thread!");
+                                        "thread");
                         }
                 }
 
@@ -939,7 +1210,7 @@ tier_start (xlator_t *this, gf_defrag_info_t *defrag)
                                 gf_msg (this->name, GF_LOG_ERROR, 0,
                                         DHT_MSG_LOG_TIER_ERROR,
                                         "Failed starting Promotion "
-                                        "thread!");
+                                        "thread");
                         }
                 }
 
@@ -948,7 +1219,7 @@ tier_start (xlator_t *this, gf_defrag_info_t *defrag)
                         if (demotion_args.return_value) {
                                 gf_msg (this->name, GF_LOG_ERROR, 0,
                                         DHT_MSG_LOG_TIER_ERROR,
-                                        "Demotion failed!");
+                                        "Demotion failed");
                         }
                         ret_demotion = demotion_args.return_value;
                 }
@@ -958,7 +1229,7 @@ tier_start (xlator_t *this, gf_defrag_info_t *defrag)
                         if (promotion_args.return_value) {
                                 gf_msg (this->name, GF_LOG_ERROR, 0,
                                         DHT_MSG_LOG_TIER_ERROR,
-                                        "Promotion failed!");
+                                        "Promotion failed");
                         }
                         ret_promotion = promotion_args.return_value;
                 }
diff --git a/xlators/features/changetimerecorder/src/changetimerecorder.c b/xlators/features/changetimerecorder/src/changetimerecorder.c
index 6ef3d76..090e54c 100644
--- a/xlators/features/changetimerecorder/src/changetimerecorder.c
+++ b/xlators/features/changetimerecorder/src/changetimerecorder.c
@@ -1381,29 +1381,287 @@ out:
 
 /*******************************ctr_ipc****************************************/
 
+/*This is the call back function per record/file from data base*/
+static int
+ctr_db_query_callback (gfdb_query_record_t *gfdb_query_record,
+                        void *args) {
+        int ret = -1;
+        char gfid_str[UUID_CANONICAL_FORM_LEN+1] = "";
+        ctr_query_cbk_args_t *query_cbk_args = args;
+
+        GF_VALIDATE_OR_GOTO ("ctr", query_cbk_args, out);
+
+        gf_uuid_unparse (gfdb_query_record->gfid, gfid_str);
+        fprintf (query_cbk_args->queryFILE, "%s|%s|%ld\n", gfid_str,
+                 gfdb_query_record->_link_info_str,
+                 gfdb_query_record->link_info_size);
+
+        query_cbk_args->count++;
+
+        ret = 0;
+out:
+        return ret;
+}
+
+/* This function does all the db queries related to tiering and
+ * generates/populates new/existing query file
+ * inputs:
+ * xlator_t *this : CTR Translator
+ * void *conn_node : Database connection
+ * char *query_file: the query file that needs to be updated
+ * gfdb_ipc_ctr_params_t *ipc_ctr_params: the query parameters
+ * Return:
+ * On success 0
+ * On failure -1
+ * */
+int
+ctr_db_query (xlator_t *this,
+              void *conn_node,
+              char *query_file,
+              gfdb_ipc_ctr_params_t *ipc_ctr_params)
+{
+        int ret = -1;
+        ctr_query_cbk_args_t query_cbk_args = {0};
+
+        GF_VALIDATE_OR_GOTO ("ctr", this, out);
+        GF_VALIDATE_OR_GOTO (this->name, conn_node, out);
+        GF_VALIDATE_OR_GOTO (this->name, query_file, out);
+        GF_VALIDATE_OR_GOTO (this->name, ipc_ctr_params, out);
+
+        /*Query for eligible files from db*/
+        query_cbk_args.queryFILE = fopen(query_file, "a+");
+        if (!query_cbk_args.queryFILE) {
+                gf_msg (this->name, GF_LOG_ERROR, errno,
+                        CTR_MSG_FATAL_ERROR,
+                        "Failed to open query file %s", query_file);
+                goto out;
+        }
+        if (!ipc_ctr_params->is_promote) {
+                if (ipc_ctr_params->write_freq_threshold == 0 &&
+                        ipc_ctr_params->read_freq_threshold == 0) {
+                                ret = find_unchanged_for_time (
+                                        conn_node,
+                                        ctr_db_query_callback,
+                                        (void *)&query_cbk_args,
+                                        &ipc_ctr_params->time_stamp);
+                } else {
+                                ret = find_unchanged_for_time_freq (
+                                        conn_node,
+                                        ctr_db_query_callback,
+                                        (void *)&query_cbk_args,
+                                        &ipc_ctr_params->time_stamp,
+                                        ipc_ctr_params->write_freq_threshold,
+                                        ipc_ctr_params->read_freq_threshold,
+                                        _gf_false);
+                }
+        } else {
+                if (ipc_ctr_params->write_freq_threshold == 0 &&
+                        ipc_ctr_params->read_freq_threshold == 0) {
+                        ret = find_recently_changed_files (
+                                conn_node,
+                                ctr_db_query_callback,
+                                (void *)&query_cbk_args,
+                                &ipc_ctr_params->time_stamp);
+                } else {
+                        ret = find_recently_changed_files_freq (
+                                conn_node,
+                                ctr_db_query_callback,
+                                (void *)&query_cbk_args,
+                                &ipc_ctr_params->time_stamp,
+                                ipc_ctr_params->write_freq_threshold,
+                                ipc_ctr_params->read_freq_threshold,
+                                _gf_false);
+                }
+        }
+        if (ret) {
+                gf_msg (this->name, GF_LOG_ERROR, 0,
+                        CTR_MSG_FATAL_ERROR,
+                        "FATAL: query from db failed");
+                        goto out;
+        }
+
+        ret = clear_files_heat (conn_node);
+        if (ret) {
+                gf_msg (this->name, GF_LOG_ERROR, 0,
+                        CTR_MSG_FATAL_ERROR,
+                        "FATAL: Failed to clear db entries");
+                        goto out;
+        }
+
+        ret = 0;
+out:
+
+        if (!ret)
+                ret = query_cbk_args.count;
+
+        if (query_cbk_args.queryFILE) {
+                fclose (query_cbk_args.queryFILE);
+                query_cbk_args.queryFILE = NULL;
+        }
+
+        return ret;
+}
+
+
+int
+ctr_ipc_helper (xlator_t *this, dict_t *in_dict,
+                dict_t *out_dict)
+{
+        int ret = -1;
+        char *ctr_ipc_ops = NULL;
+        gf_ctr_private_t *priv = NULL;
+        char *db_version = NULL;
+        char *db_param_key = NULL;
+        char *db_param = NULL;
+        char *query_file = NULL;
+        gfdb_ipc_ctr_params_t *ipc_ctr_params = NULL;
+
+
+        GF_VALIDATE_OR_GOTO ("ctr", this, out);
+        GF_VALIDATE_OR_GOTO (this->name, this->private, out);
+        priv = this->private;
+        GF_VALIDATE_OR_GOTO (this->name, priv->_db_conn, out);
+        GF_VALIDATE_OR_GOTO (this->name, in_dict, out);
+        GF_VALIDATE_OR_GOTO (this->name, out_dict, out);
+
+        GET_DB_PARAM_FROM_DICT(this->name, in_dict, GFDB_IPC_CTR_KEY,
+                                ctr_ipc_ops, out);
+
+        /*if its a db clear operation */
+        if (strncmp (ctr_ipc_ops, GFDB_IPC_CTR_CLEAR_OPS,
+                        strlen (GFDB_IPC_CTR_CLEAR_OPS)) == 0) {
+
+                ret = clear_files_heat (priv->_db_conn);
+                if (ret)
+                        goto out;
+
+        } /* if its a query operation, in  which case its query + clear db*/
+        else if (strncmp (ctr_ipc_ops, GFDB_IPC_CTR_QUERY_OPS,
+                                strlen (GFDB_IPC_CTR_QUERY_OPS)) == 0) {
+
+                ret = dict_get_str (in_dict, GFDB_IPC_CTR_GET_QFILE_PATH,
+                                                                &query_file);
+                if (ret) {
+                        gf_msg(this->name, GF_LOG_ERROR, 0, CTR_MSG_SET,
+                                        "Failed extracting query file path");
+                        goto out;
+                }
+
+                ret = dict_get_bin (in_dict, GFDB_IPC_CTR_GET_QUERY_PARAMS,
+                                   (void *)&ipc_ctr_params);
+                if (ret) {
+                        gf_msg(this->name, GF_LOG_ERROR, 0, CTR_MSG_SET,
+                                        "Failed extracting query parameters");
+                        goto out;
+                }
+
+                ret = ctr_db_query (this, priv->_db_conn, query_file,
+                                ipc_ctr_params);
+
+                ret = dict_set_int32 (out_dict,
+                                      GFDB_IPC_CTR_RET_QUERY_COUNT, ret);
+                if (ret) {
+                        gf_msg(this->name, GF_LOG_ERROR, 0, CTR_MSG_SET,
+                                        "Failed setting query reply");
+                        goto out;
+                }
+
+        } /* if its a query for db version */
+        else if (strncmp (ctr_ipc_ops, GFDB_IPC_CTR_GET_DB_VERSION_OPS,
+                        strlen (GFDB_IPC_CTR_GET_DB_VERSION_OPS)) == 0) {
+
+                ret = get_db_version (priv->_db_conn, &db_version);
+                if (ret == -1 || !db_version) {
+                        gf_msg(this->name, GF_LOG_ERROR, 0, CTR_MSG_SET,
+                                        "Failed extracting db version ");
+                        goto out;
+                }
+
+                SET_DB_PARAM_TO_DICT(this->name, out_dict,
+                                        GFDB_IPC_CTR_RET_DB_VERSION,
+                                        db_version, ret, error);
+
+        } /* if its a query for a db setting */
+        else if (strncmp (ctr_ipc_ops, GFDB_IPC_CTR_GET_DB_PARAM_OPS,
+                                strlen (GFDB_IPC_CTR_GET_DB_PARAM_OPS)) == 0) {
+
+                ret = dict_get_str (in_dict, GFDB_IPC_CTR_GET_DB_KEY,
+                                &db_param_key);
+                if (ret) {
+                        gf_msg(this->name, GF_LOG_ERROR, 0, CTR_MSG_SET,
+                                        "Failed extracting db param key");
+                        goto out;
+                }
+
+                ret = get_db_setting (priv->_db_conn, db_param_key, &db_param);
+                if (ret == -1 || !db_param) {
+                        goto out;
+                }
+
+                SET_DB_PARAM_TO_DICT(this->name, out_dict,
+                                        db_param_key,
+                                        db_param, ret, error);
+        } /* default case */
+        else {
+                goto out;
+        }
+
+
+        ret = 0;
+        goto out;
+error:
+        GF_FREE (db_param_key);
+        GF_FREE (db_param);
+        GF_FREE (db_version);
+out:
+        return ret;
+}
+
+
 /* IPC Call from tier migrator to clear the heat on the DB */
 int32_t
-ctr_ipc (call_frame_t *frame, xlator_t *this, int32_t op, dict_t *xdata)
+ctr_ipc (call_frame_t *frame, xlator_t *this, int32_t op,
+        dict_t *in_dict)
 {
         int ret                         = -1;
-        gf_ctr_private_t *_priv         = NULL;
+        gf_ctr_private_t *priv         = NULL;
+        dict_t *out_dict                = NULL;
 
         GF_ASSERT(this);
-        _priv = this->private;
-        GF_ASSERT (_priv);
-        GF_ASSERT(_priv->_db_conn);
+        priv = this->private;
+        GF_ASSERT (priv);
+        GF_ASSERT(priv->_db_conn);
+        GF_VALIDATE_OR_GOTO (this->name, in_dict, wind);
+
 
         if (op != GF_IPC_TARGET_CTR)
                 goto wind;
 
-        ret = clear_files_heat (_priv->_db_conn);
+        out_dict = dict_new();
+        if (!out_dict) {
+                goto out;
+        }
+
+        ret = ctr_ipc_helper (this, in_dict, out_dict);
+        if (ret) {
+                gf_msg(this->name, GF_LOG_ERROR, 0, CTR_MSG_SET,
+                "Failed in ctr_ipc_helper");
+        }
+out:
+
+        STACK_UNWIND_STRICT (ipc, frame, ret, 0, out_dict);
+
+        if (out_dict)
+                dict_unref(out_dict);
 
-        STACK_UNWIND_STRICT (ipc, frame, ret, 0, NULL);
         return 0;
 
  wind:
         STACK_WIND (frame, default_ipc_cbk, FIRST_CHILD (this),
-                    FIRST_CHILD (this)->fops->ipc, op, xdata);
+                    FIRST_CHILD (this)->fops->ipc, op, in_dict);
+
+
+
         return 0;
 }
 
@@ -1415,35 +1673,35 @@ reconfigure (xlator_t *this, dict_t *options)
 {
         char *temp_str = NULL;
         int ret = 0;
-        gf_ctr_private_t *_priv = NULL;
+        gf_ctr_private_t *priv = NULL;
 
-        _priv = this->private;
+        priv = this->private;
         if (dict_get_str(options, "changetimerecorder.frequency",
                          &temp_str)) {
                 gf_msg(this->name, GF_LOG_INFO, 0, CTR_MSG_SET, "set!");
         }
 
-        GF_OPTION_RECONF ("ctr-enabled", _priv->enabled, options,
+        GF_OPTION_RECONF ("ctr-enabled", priv->enabled, options,
                           bool, out);
 
-        GF_OPTION_RECONF ("record-counters", _priv->ctr_record_counter, options,
+        GF_OPTION_RECONF ("record-counters", priv->ctr_record_counter, options,
                           bool, out);
 
-        GF_OPTION_RECONF ("ctr_link_consistency", _priv->ctr_link_consistency,
+        GF_OPTION_RECONF ("ctr_link_consistency", priv->ctr_link_consistency,
                         options, bool, out);
 
         GF_OPTION_RECONF ("ctr_inode_heal_expire_period",
-                                _priv->ctr_inode_heal_expire_period,
+                                priv->ctr_inode_heal_expire_period,
                                 options, uint64, out);
 
         GF_OPTION_RECONF ("ctr_hardlink_heal_expire_period",
-                                _priv->ctr_hardlink_heal_expire_period,
+                                priv->ctr_hardlink_heal_expire_period,
                                 options, uint64, out);
 
-        GF_OPTION_RECONF ("record-exit", _priv->ctr_record_unwind, options,
+        GF_OPTION_RECONF ("record-exit", priv->ctr_record_unwind, options,
                           bool, out);
 
-        GF_OPTION_RECONF ("record-entry", _priv->ctr_record_wind, options,
+        GF_OPTION_RECONF ("record-entry", priv->ctr_record_wind, options,
                           bool, out);
 
 out:
@@ -1456,7 +1714,7 @@ out:
 int32_t
 init (xlator_t *this)
 {
-        gf_ctr_private_t *_priv = NULL;
+        gf_ctr_private_t *priv = NULL;
         int ret_db              = -1;
         dict_t *params_dict      = NULL;
 
@@ -1475,8 +1733,8 @@ init (xlator_t *this)
                         "dangling volume. check volfile ");
         }
 
-        _priv = GF_CALLOC (1, sizeof (*_priv), gf_ctr_mt_private_t);
-        if (!_priv) {
+        priv = GF_CALLOC (1, sizeof (*priv), gf_ctr_mt_private_t);
+        if (!priv) {
                 gf_msg (this->name, GF_LOG_ERROR, ENOMEM,
                         CTR_MSG_CALLOC_FAILED,
                         "Calloc didnt work!!!");
@@ -1484,20 +1742,20 @@ init (xlator_t *this)
         }
 
         /*Default values for the translator*/
-        _priv->ctr_record_wind          = _gf_true;
-        _priv->ctr_record_unwind        = _gf_false;
-        _priv->ctr_hot_brick            = _gf_false;
-        _priv->gfdb_db_type             = GFDB_SQLITE3;
-        _priv->gfdb_sync_type           = GFDB_DB_SYNC;
-        _priv->enabled                  = _gf_true;
-        _priv->_db_conn                 = NULL;
-        _priv->ctr_hardlink_heal_expire_period =
+        priv->ctr_record_wind          = _gf_true;
+        priv->ctr_record_unwind        = _gf_false;
+        priv->ctr_hot_brick            = _gf_false;
+        priv->gfdb_db_type             = GFDB_SQLITE3;
+        priv->gfdb_sync_type           = GFDB_DB_SYNC;
+        priv->enabled                  = _gf_true;
+        priv->_db_conn                 = NULL;
+        priv->ctr_hardlink_heal_expire_period =
                                 CTR_DEFAULT_HARDLINK_EXP_PERIOD;
-        _priv->ctr_inode_heal_expire_period =
+        priv->ctr_inode_heal_expire_period =
                                 CTR_DEFAULT_INODE_EXP_PERIOD;
 
         /*Extract ctr xlator options*/
-        ret_db = extract_ctr_options (this, _priv);
+        ret_db = extract_ctr_options (this, priv);
         if (ret_db) {
                 gf_msg (this->name, GF_LOG_ERROR, 0,
                         CTR_MSG_EXTRACT_CTR_XLATOR_OPTIONS_FAILED,
@@ -1514,7 +1772,7 @@ init (xlator_t *this)
         }
 
         /*Extract db params options*/
-        ret_db = extract_db_params(this, params_dict, _priv->gfdb_db_type);
+        ret_db = extract_db_params(this, params_dict, priv->gfdb_db_type);
         if (ret_db) {
                 gf_msg (this->name, GF_LOG_ERROR, 0,
                         CTR_MSG_EXTRACT_DB_PARAM_OPTIONS_FAILED,
@@ -1532,8 +1790,8 @@ init (xlator_t *this)
         }
 
         /*Initialize Database Connection*/
-        _priv->_db_conn = init_db(params_dict, _priv->gfdb_db_type);
-        if (!_priv->_db_conn) {
+        priv->_db_conn = init_db(params_dict, priv->gfdb_db_type);
+        if (!priv->_db_conn) {
                 gf_msg (this->name, GF_LOG_ERROR, 0,
                        CTR_MSG_FATAL_ERROR,
                        "FATAL: Failed initializing data base");
@@ -1549,10 +1807,10 @@ error:
         if (this)
                 mem_pool_destroy (this->local_pool);
 
-        if (_priv) {
-                GF_FREE (_priv->ctr_db_path);
+        if (priv) {
+                GF_FREE (priv->ctr_db_path);
         }
-        GF_FREE (_priv);
+        GF_FREE (priv);
 
         if (params_dict)
                 dict_unref (params_dict);
@@ -1564,7 +1822,7 @@ out:
         if (params_dict)
                 dict_unref (params_dict);
 
-        this->private = (void *)_priv;
+        this->private = (void *)priv;
         return 0;
 }
 
diff --git a/xlators/features/changetimerecorder/src/ctr-helper.h b/xlators/features/changetimerecorder/src/ctr-helper.h
index 516dfd4..51dec44 100644
--- a/xlators/features/changetimerecorder/src/ctr-helper.h
+++ b/xlators/features/changetimerecorder/src/ctr-helper.h
@@ -35,6 +35,13 @@
 #define CTR_DEFAULT_HARDLINK_EXP_PERIOD 300  /* Five mins */
 #define CTR_DEFAULT_INODE_EXP_PERIOD    300 /* Five mins */
 
+
+typedef struct ctr_query_cbk_args {
+        FILE *queryFILE;
+        int count;
+} ctr_query_cbk_args_t;
+
+
 /*CTR Xlator Private structure*/
 typedef struct gf_ctr_private {
         gf_boolean_t                    enabled;
-- 
1.7.1

