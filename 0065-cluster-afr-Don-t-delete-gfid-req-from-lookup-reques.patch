From 531bbee43de55dd9c38072b34f9aab181873aa6c Mon Sep 17 00:00:00 2001
From: Pranith Kumar K <pkarampu@redhat.com>
Date: Sat, 27 Feb 2016 23:08:06 +0530
Subject: [PATCH 65/80] cluster/afr: Don't delete gfid-req from lookup request

Problem:
Afr does dict_ref of the xattr_req that comes to it and deletes "gfid-req" key.
Dht uses same dict to send lookup to other subvolumes. So in case of
directories and more than 1 dht subvolumes, second subvolume till the last
subvolume won't get a lookup request with "gfid-req". So gfid reset never
happens on the directories in distributed replicate subvolume for 2nd till last
subvolumes.

Fix:
Make a copy of lookup xattr request.

Also fixed replies_wipe possibly resetting gfid to NULL gfid

 >BUG: 1312816
 >Change-Id: Ic16260e5a4664837d069c1dc05b9e96ca05bda88
 >Signed-off-by: Pranith Kumar K <pkarampu@redhat.com>
 >Reviewed-on: http://review.gluster.org/13545
 >Smoke: Gluster Build System <jenkins@build.gluster.com>
 >NetBSD-regression: NetBSD Build System <jenkins@build.gluster.org>
 >CentOS-regression: Gluster Build System <jenkins@build.gluster.com>
 >Reviewed-by: Krutika Dhananjay <kdhananj@redhat.com>

BUG: 1318427
Change-Id: Ic6b5e8c36685812031fd5c5497ae6b600e23bc38
Signed-off-by: Pranith Kumar K <pkarampu@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/71971
---
 tests/basic/afr/gfid-heal.t                  |   20 ++++++++++++++++++++
 xlators/cluster/afr/src/afr-common.c         |   10 +++++++---
 xlators/cluster/afr/src/afr-self-heal-name.c |    4 ++--
 3 files changed, 29 insertions(+), 5 deletions(-)
 create mode 100644 tests/basic/afr/gfid-heal.t

diff --git a/tests/basic/afr/gfid-heal.t b/tests/basic/afr/gfid-heal.t
new file mode 100644
index 0000000..e570f3d
--- /dev/null
+++ b/tests/basic/afr/gfid-heal.t
@@ -0,0 +1,20 @@
+#!/bin/bash
+#gfid self-heal test on distributed replica. Make sure all the gfids are same
+#and the gfid exists on all the bricks
+
+. $(dirname $0)/../../include.rc
+. $(dirname $0)/../../volume.rc
+cleanup;
+
+TEST glusterd
+TEST pidof glusterd
+TEST $CLI volume create $V0 replica 2 $H0:$B0/brick{0,1,2,3}
+TEST $CLI volume start $V0
+TEST $GFS --volfile-id=$V0 --volfile-server=$H0 $M0;
+
+TEST mkdir $B0/brick{0,1,2,3}/d
+sleep 2 #to prevent is_fresh_file code path
+TEST stat $M0/d
+gfid_count=$(getfattr -d -m. -e hex $B0/brick{0,1,2,3}/d 2>&1 | grep trusted.gfid | wc -l)
+EXPECT 4 echo $gfid_count
+cleanup;
diff --git a/xlators/cluster/afr/src/afr-common.c b/xlators/cluster/afr/src/afr-common.c
index 6b393c7..308766c 100644
--- a/xlators/cluster/afr/src/afr-common.c
+++ b/xlators/cluster/afr/src/afr-common.c
@@ -2547,12 +2547,16 @@ afr_lookup (call_frame_t *frame, xlator_t *this, loc_t *loc, dict_t *xattr_req)
 	if (xattr_req) {
 		/* If xattr_req was null, afr_lookup_xattr_req_prepare() will
 		   allocate one for us */
-                ret = dict_get_ptr (xattr_req, "gfid-req", &gfid_req);
+		local->xattr_req = dict_copy_with_ref (xattr_req, NULL);
+		if (!local->xattr_req) {
+		        op_errno = ENOMEM;
+		        goto out;
+                }
+                ret = dict_get_ptr (local->xattr_req, "gfid-req", &gfid_req);
                 if (ret == 0) {
                         gf_uuid_copy (local->cont.lookup.gfid_req, gfid_req);
-                        dict_del (xattr_req, "gfid-req");
+                        dict_del (local->xattr_req, "gfid-req");
                 }
-		local->xattr_req = dict_ref (xattr_req);
         }
 
 	afr_read_subvol_get (loc->parent, this, NULL, &event,
diff --git a/xlators/cluster/afr/src/afr-self-heal-name.c b/xlators/cluster/afr/src/afr-self-heal-name.c
index e32b81c..6155298 100644
--- a/xlators/cluster/afr/src/afr-self-heal-name.c
+++ b/xlators/cluster/afr/src/afr-self-heal-name.c
@@ -88,11 +88,11 @@ __afr_selfheal_assign_gfid (xlator_t *this, inode_t *parent, uuid_t pargfid,
          *      __afr_selfheal_name_impunge().
          */
 
-        afr_replies_wipe (replies, priv->child_count);
-
         AFR_ONLIST (locked_on, new_frame, afr_selfheal_discover_cbk, lookup,
                     &loc, xdata);
 
+        afr_replies_wipe (replies, priv->child_count);
+
         afr_replies_copy (replies, new_local->replies, priv->child_count);
 
 out:
-- 
1.7.1

