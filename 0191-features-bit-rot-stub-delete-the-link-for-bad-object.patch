From 5efa17e2e8cc63e3145e3e05c1e62172ca2bf590 Mon Sep 17 00:00:00 2001
From: Raghavendra Bhat <raghavendra@redhat.com>
Date: Wed, 25 Nov 2015 15:25:26 +0530
Subject: [PATCH 191/191] features/bit-rot-stub: delete the link for bad object in quarantine directory

    Backport of http://review.gluster.org/#/c/12743/

When the bad object is deleted (as of now manually from the backend itself),
along with its gfid handle, the entry for the bad object in the quarantne
directory is left as it is (it also can be removed manually though). But the
next lookup of the object upon not finding it in the backend, sends forget on
the in-memory inode. If the stale link for the gfid still exists in the
quarantine directory, bir-rot-stub will unlink the entry in its forget or in
the next failed lookup on that object with errno being ENOENT.

Change-Id: If84292d3e44707dfa11fa29023b3d9f691b8f0f3
BUG: 1285238
Signed-off-by: Raghavendra Bhat <raghavendra@redhat.com>
Reviewed-by: Venky Shankar <vshankar@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/64084
Reviewed-by: Kotresh Hiremath Ravishankar <khiremat@redhat.com>
Tested-by: Venky Shankar <vshankar@redhat.com>
---
 .../bit-rot/src/stub/bit-rot-stub-helpers.c        |   29 ++++++++++
 .../bit-rot/src/stub/bit-rot-stub-messages.h       |    9 +++-
 xlators/features/bit-rot/src/stub/bit-rot-stub.c   |   57 +++++++++++++++++++-
 xlators/features/bit-rot/src/stub/bit-rot-stub.h   |    2 +
 4 files changed, 95 insertions(+), 2 deletions(-)

diff --git a/xlators/features/bit-rot/src/stub/bit-rot-stub-helpers.c b/xlators/features/bit-rot/src/stub/bit-rot-stub-helpers.c
index f637e15..306b44d 100644
--- a/xlators/features/bit-rot/src/stub/bit-rot-stub-helpers.c
+++ b/xlators/features/bit-rot/src/stub/bit-rot-stub-helpers.c
@@ -194,6 +194,35 @@ out:
         return -1;
 }
 
+int
+br_stub_del (xlator_t *this, uuid_t gfid)
+{
+        int32_t      op_errno __attribute__((unused)) = 0;
+        br_stub_private_t *priv = NULL;
+        int          ret = 0;
+        char         gfid_path[PATH_MAX] = {0};
+
+        priv = this->private;
+        GF_ASSERT_AND_GOTO_WITH_ERROR (this->name, !gf_uuid_is_null (gfid),
+                                       out, op_errno, EINVAL);
+        br_stub_linked_entry (priv, gfid_path, gfid,
+                              sizeof (gfid_path));
+        ret = sys_unlink (gfid_path);
+        if (ret && (errno != ENOENT)) {
+                gf_msg (this->name, GF_LOG_ERROR, errno,
+                        BRS_MSG_BAD_OBJ_UNLINK_FAIL,
+                        "%s: failed to delete bad object link from quarantine "
+                        "directory", gfid_path);
+                ret = -errno;
+                goto out;
+        }
+
+        ret = 0;
+
+out:
+        return ret;
+}
+
 static int
 br_stub_check_stub_directory (xlator_t *this, char *fullpath)
 {
diff --git a/xlators/features/bit-rot/src/stub/bit-rot-stub-messages.h b/xlators/features/bit-rot/src/stub/bit-rot-stub-messages.h
index ee39e4c..c0fcfd3 100644
--- a/xlators/features/bit-rot/src/stub/bit-rot-stub-messages.h
+++ b/xlators/features/bit-rot/src/stub/bit-rot-stub-messages.h
@@ -40,7 +40,7 @@
  */
 
 #define GLFS_BITROT_STUB_BASE                   GLFS_MSGID_COMP_BITROT_STUB
-#define GLFS_BITROT_STUB_NUM_MESSAGES           30
+#define GLFS_BITROT_STUB_NUM_MESSAGES           31
 #define GLFS_MSGID_END         (GLFS_BITROT_STUB_BASE + \
                                 GLFS_BITROT_STUB_NUM_MESSAGES + 1)
 /* Messaged with message IDs */
@@ -258,6 +258,13 @@
  * @recommendedaction
  *
  */
+#define BRS_MSG_BAD_OBJ_UNLINK_FAIL        (GLFS_BITROT_STUB_BASE + 31)
+/*!
+ * @messageid
+ * @diagnosis
+ * @recommendedaction
+ *
+ */
 /*------------*/
 
 #define glfs_msg_end_x GLFS_MSGID_END, "Invalid: End of messages"
diff --git a/xlators/features/bit-rot/src/stub/bit-rot-stub.c b/xlators/features/bit-rot/src/stub/bit-rot-stub.c
index 39dddcd..7f455f2 100644
--- a/xlators/features/bit-rot/src/stub/bit-rot-stub.c
+++ b/xlators/features/bit-rot/src/stub/bit-rot-stub.c
@@ -2578,6 +2578,44 @@ br_stub_readdirp (call_frame_t *frame, xlator_t *this,
 
 /* lookup() */
 
+/**
+ * This function mainly handles the ENOENT error for the bad objects. Though
+ * br_stub_forget () handles removal of the link for the bad object from the
+ * quarantine directory, its better to handle it in lookup as well, where
+ * a failed lookup on a bad object with ENOENT, will trigger deletion of the
+ * link for the bad object from quarantine directory. So whoever comes first
+ * either forget () or lookup () will take care of removing the link.
+ */
+void
+br_stub_handle_lookup_error (xlator_t *this, inode_t *inode, int32_t op_errno)
+{
+        int32_t     ret = -1;
+        uint64_t   ctx_addr = 0;
+        br_stub_inode_ctx_t *ctx = NULL;
+
+        if (op_errno != ENOENT)
+                goto out;
+
+        if (!inode_is_linked (inode))
+                goto out;
+
+        ret = br_stub_get_inode_ctx (this, inode, &ctx_addr);
+        if (ret)
+                goto out;
+
+        ctx = (br_stub_inode_ctx_t *)(long)ctx_addr;
+
+        LOCK (&inode->lock);
+        {
+                if (__br_stub_is_bad_object (ctx))
+                        (void) br_stub_del (this, inode->gfid);
+        }
+        UNLOCK (&inode->lock);
+
+out:
+        return;
+}
+
 int
 br_stub_lookup_cbk (call_frame_t *frame, void *cookie,
                     xlator_t *this, int op_ret, int op_errno, inode_t *inode,
@@ -2585,8 +2623,11 @@ br_stub_lookup_cbk (call_frame_t *frame, void *cookie,
 {
         int32_t ret = 0;
 
-        if (op_ret < 0)
+        if (op_ret < 0) {
+                (void) br_stub_handle_lookup_error (this, inode, op_errno);
                 goto unwind;
+        }
+
         if (!IA_ISREG (stbuf->ia_type))
                 goto unwind;
 
@@ -2740,6 +2781,20 @@ br_stub_forget (xlator_t *this, inode_t *inode)
                 return 0;
 
         ctx = (br_stub_inode_ctx_t *) (long) ctx_addr;
+
+        LOCK (&inode->lock);
+        {
+                /**
+                 * Ignoring the return value of br_stub_del ().
+                 * There is not much that can be done if unlinking
+                 * of the entry in the quarantine directory fails.
+                 * The failure is logged.
+                 */
+                if (__br_stub_is_bad_object (ctx))
+                        (void) br_stub_del (this, inode->gfid);
+        }
+        UNLOCK (&inode->lock);
+
         GF_FREE (ctx);
 
         return 0;
diff --git a/xlators/features/bit-rot/src/stub/bit-rot-stub.h b/xlators/features/bit-rot/src/stub/bit-rot-stub.h
index 35476ff..22f027d 100644
--- a/xlators/features/bit-rot/src/stub/bit-rot-stub.h
+++ b/xlators/features/bit-rot/src/stub/bit-rot-stub.h
@@ -462,5 +462,7 @@ int32_t
 br_stub_readdir_wrapper (call_frame_t *frame, xlator_t *this,
                          fd_t *fd, size_t size, off_t off, dict_t *xdata);
 
+int
+br_stub_del (xlator_t *this, uuid_t gfid);
 
 #endif /* __BIT_ROT_STUB_H__ */
-- 
1.7.1

