From b595b023a8035a3b35472d32bfc87b673896c73a Mon Sep 17 00:00:00 2001
From: vmallika <vmallika@redhat.com>
Date: Wed, 16 Mar 2016 13:31:10 +0530
Subject: [PATCH 52/80] marker: set inode ctx before lookup unwind

This is a backport of http://review.gluster.org/13748

When a file is unlinked before it was accounted by the marker,
then we may see error "ctx for the node ... is NULL" at many places.
This is actually not an error and can be ignored.

It is better to set the inode ctx before lookup/create is unwind
back to protocol server

> Change-Id: I462b5542951f2fc2964f59af7a31978979dab1de
> BUG: 1318158
> Signed-off-by: vmallika <vmallika@redhat.com>
> Reviewed-on: http://review.gluster.org/13748
> Smoke: Gluster Build System <jenkins@build.gluster.com>
> NetBSD-regression: NetBSD Build System <jenkins@build.gluster.org>
> CentOS-regression: Gluster Build System <jenkins@build.gluster.com>
> Reviewed-by: Raghavendra G <rgowdapp@redhat.com>

Change-Id: I3d2ce5714f83bf3ac6e7b74662ea87a03fdd2e8e
BUG: 1318170
Signed-off-by: vmallika <vmallika@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/71535
Reviewed-by: Raghavendra Gowdappa <rgowdapp@redhat.com>
Tested-by: Raghavendra Gowdappa <rgowdapp@redhat.com>
---
 xlators/features/marker/src/marker-quota-helper.c |   21 ++++-
 xlators/features/marker/src/marker-quota.c        |   24 ++----
 xlators/features/marker/src/marker.c              |   93 +++++++++++++++++----
 3 files changed, 99 insertions(+), 39 deletions(-)

diff --git a/xlators/features/marker/src/marker-quota-helper.c b/xlators/features/marker/src/marker-quota-helper.c
index 4aba599..c2268bf 100644
--- a/xlators/features/marker/src/marker-quota-helper.c
+++ b/xlators/features/marker/src/marker-quota-helper.c
@@ -65,9 +65,13 @@ out:
 int32_t
 mq_inode_loc_fill (const char *parent_gfid, inode_t *inode, loc_t *loc)
 {
-        char            *resolvedpath = NULL;
-        inode_t         *parent       = NULL;
-        int              ret          = -1;
+        char                *resolvedpath = NULL;
+        inode_t             *parent       = NULL;
+        quota_inode_ctx_t   *ctx          = NULL;
+        xlator_t            *this         = NULL;
+        int                  ret          = -1;
+
+        this = THIS;
 
         if ((!inode) || (!loc))
                 return ret;
@@ -101,6 +105,17 @@ ignore_parent:
         if (ret < 0)
                 goto err;
 
+        ret = mq_inode_ctx_get (inode, this, &ctx);
+        if (ret < 0 || ctx == NULL)
+                ctx = mq_inode_ctx_new (inode, this);
+        if (ctx == NULL) {
+                gf_log (this->name, GF_LOG_WARNING, "mq_inode_ctx_new "
+                        "failed for %s", uuid_utoa (inode->gfid));
+                ret = -1;
+                goto err;
+        }
+        ret = 0;
+
 err:
         if (parent)
                 inode_unref (parent);
diff --git a/xlators/features/marker/src/marker-quota.c b/xlators/features/marker/src/marker-quota.c
index 65973ed..5343a94 100644
--- a/xlators/features/marker/src/marker-quota.c
+++ b/xlators/features/marker/src/marker-quota.c
@@ -1038,26 +1038,14 @@ mq_prevalidate_txn (xlator_t *this, loc_t *origin_loc, loc_t *loc,
                 }
         }
 
-        if (ctx)
-                ret = mq_inode_ctx_get (loc->inode, this, ctx);
-        else
-                ret = mq_inode_ctx_get (loc->inode, this, &ctxtmp);
-
+        ret = mq_inode_ctx_get (loc->inode, this, &ctxtmp);
         if (ret < 0) {
-                if (ctx) {
-                        *ctx = mq_inode_ctx_new (loc->inode, this);
-                        if (*ctx == NULL) {
-                                gf_log_callingfn (this->name, GF_LOG_WARNING,
-                                                  "mq_inode_ctx_new failed for "
-                                                  "%s", loc->path);
-                                ret = -1;
-                                goto out;
-                        }
-                } else {
-                        gf_log_callingfn (this->name, GF_LOG_WARNING, "ctx for "
-                                          "is NULL for %s", loc->path);
-                }
+                gf_log_callingfn (this->name, GF_LOG_WARNING, "inode ctx for "
+                                  "is NULL for %s", loc->path);
+                goto out;
         }
+        if (ctx)
+                *ctx = ctxtmp;
 
         ret = 0;
 out:
diff --git a/xlators/features/marker/src/marker.c b/xlators/features/marker/src/marker.c
index 61c59f5..e731f19 100644
--- a/xlators/features/marker/src/marker.c
+++ b/xlators/features/marker/src/marker.c
@@ -717,6 +717,7 @@ marker_mkdir_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
 {
         marker_conf_t      *priv    = NULL;
         marker_local_t     *local   = NULL;
+        quota_inode_ctx_t  *ctx     = NULL;
 
         if (op_ret == -1) {
                 gf_log (this->name, GF_LOG_TRACE, "error occurred "
@@ -726,6 +727,17 @@ marker_mkdir_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
         local = (marker_local_t *) frame->local;
 
         frame->local = NULL;
+        priv = this->private;
+
+        if (op_ret >= 0 && inode && (priv->feature_enabled & GF_QUOTA)) {
+                ctx = mq_inode_ctx_new (inode, this);
+                if (ctx == NULL) {
+                        gf_log (this->name, GF_LOG_WARNING, "mq_inode_ctx_new "
+                                "failed for %s", uuid_utoa (inode->gfid));
+                        op_ret = -1;
+                        op_errno = ENOMEM;
+                }
+        }
 
         STACK_UNWIND_STRICT (mkdir, frame, op_ret, op_errno, inode,
                              buf, preparent, postparent, xdata);
@@ -736,8 +748,6 @@ marker_mkdir_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
         if (gf_uuid_is_null (local->loc.gfid))
                 gf_uuid_copy (local->loc.gfid, buf->ia_gfid);
 
-        priv = this->private;
-
         if (priv->feature_enabled & GF_QUOTA)
                 mq_create_xattrs_txn (this, &local->loc, NULL);
 
@@ -792,6 +802,7 @@ marker_create_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
 {
         marker_local_t     *local   = NULL;
         marker_conf_t      *priv    = NULL;
+        quota_inode_ctx_t  *ctx     = NULL;
 
         if (op_ret == -1) {
                 gf_log (this->name, GF_LOG_TRACE, "error occurred "
@@ -801,6 +812,17 @@ marker_create_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
         local = (marker_local_t *) frame->local;
 
         frame->local = NULL;
+        priv = this->private;
+
+        if (op_ret >= 0 && inode && (priv->feature_enabled & GF_QUOTA)) {
+                ctx = mq_inode_ctx_new (inode, this);
+                if (ctx == NULL) {
+                        gf_log (this->name, GF_LOG_WARNING, "mq_inode_ctx_new "
+                                "failed for %s", uuid_utoa (inode->gfid));
+                        op_ret = -1;
+                        op_errno = ENOMEM;
+                }
+        }
 
         STACK_UNWIND_STRICT (create, frame, op_ret, op_errno, fd, inode, buf,
                              preparent, postparent, xdata);
@@ -811,8 +833,6 @@ marker_create_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
         if (gf_uuid_is_null (local->loc.gfid))
                 gf_uuid_copy (local->loc.gfid, buf->ia_gfid);
 
-        priv = this->private;
-
         if (priv->feature_enabled & GF_QUOTA)
                 mq_create_xattrs_txn (this, &local->loc, buf);
 
@@ -1894,6 +1914,7 @@ marker_symlink_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
 {
         marker_conf_t      *priv    = NULL;
         marker_local_t     *local   = NULL;
+        quota_inode_ctx_t  *ctx     = NULL;
 
         if (op_ret == -1) {
                 gf_log (this->name, GF_LOG_TRACE, "%s occurred while "
@@ -1903,6 +1924,17 @@ marker_symlink_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
         local = (marker_local_t *) frame->local;
 
         frame->local = NULL;
+        priv = this->private;
+
+        if (op_ret >= 0 && inode && (priv->feature_enabled & GF_QUOTA)) {
+                ctx = mq_inode_ctx_new (inode, this);
+                if (ctx == NULL) {
+                        gf_log (this->name, GF_LOG_WARNING, "mq_inode_ctx_new "
+                                "failed for %s", uuid_utoa (inode->gfid));
+                        op_ret = -1;
+                        op_errno = ENOMEM;
+                }
+        }
 
         STACK_UNWIND_STRICT (symlink, frame, op_ret, op_errno, inode, buf,
                              preparent, postparent, xdata);
@@ -1913,8 +1945,6 @@ marker_symlink_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
         if (gf_uuid_is_null (local->loc.gfid))
                 gf_uuid_copy (local->loc.gfid, buf->ia_gfid);
 
-        priv = this->private;
-
         if (priv->feature_enabled & GF_QUOTA) {
                 mq_create_xattrs_txn (this, &local->loc, buf);
         }
@@ -1969,6 +1999,7 @@ marker_mknod_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
 {
         marker_local_t     *local   = NULL;
         marker_conf_t      *priv    = NULL;
+        quota_inode_ctx_t  *ctx     = NULL;
 
         if (op_ret == -1) {
                 gf_log (this->name, GF_LOG_TRACE, "%s occurred with "
@@ -1978,6 +2009,17 @@ marker_mknod_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
         local = (marker_local_t *) frame->local;
 
         frame->local = NULL;
+        priv = this->private;
+
+        if (op_ret >= 0 && inode && (priv->feature_enabled & GF_QUOTA)) {
+                ctx = mq_inode_ctx_new (inode, this);
+                if (ctx == NULL) {
+                        gf_log (this->name, GF_LOG_WARNING, "mq_inode_ctx_new "
+                                "failed for %s", uuid_utoa (inode->gfid));
+                        op_ret = -1;
+                        op_errno = ENOMEM;
+                }
+        }
 
         STACK_UNWIND_STRICT (mknod, frame, op_ret, op_errno, inode,
                              buf, preparent, postparent, xdata);
@@ -1988,8 +2030,6 @@ marker_mknod_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
         if (gf_uuid_is_null (local->loc.gfid))
                 gf_uuid_copy (local->loc.gfid, buf->ia_gfid);
 
-        priv = this->private;
-
         if ((priv->feature_enabled & GF_QUOTA) && (S_ISREG (local->mode))) {
                 mq_create_xattrs_txn (this, &local->loc, buf);
         }
@@ -2815,10 +2855,11 @@ marker_lookup_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
                    int32_t op_ret, int32_t op_errno, inode_t *inode,
                    struct iatt *buf, dict_t *dict, struct iatt *postparent)
 {
-        marker_conf_t  *priv                       = NULL;
-        marker_local_t *local                      = NULL;
-        dict_t         *xattrs                     = NULL;
-        int32_t         ret                        = -1;
+        marker_conf_t      *priv                       = NULL;
+        marker_local_t     *local                      = NULL;
+        dict_t             *xattrs                     = NULL;
+        quota_inode_ctx_t  *ctx                        = NULL;
+        int32_t             ret                        = -1;
 
         priv = this->private;
         local = (marker_local_t *) frame->local;
@@ -2849,6 +2890,16 @@ marker_lookup_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
                 xattrs = dict_ref (dict);
         }
 
+        if (op_ret >= 0 && inode && (priv->feature_enabled & GF_QUOTA)) {
+                ctx = mq_inode_ctx_new (inode, this);
+                if (ctx == NULL) {
+                        gf_log (this->name, GF_LOG_WARNING, "mq_inode_ctx_new "
+                                "failed for %s", uuid_utoa (inode->gfid));
+                        op_ret = -1;
+                        op_errno = ENOMEM;
+                }
+        }
+
 unwind:
         STACK_UNWIND_STRICT (lookup, frame, op_ret, op_errno, inode, buf,
                              xattrs, postparent);
@@ -2969,12 +3020,13 @@ marker_readdirp_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
                      int op_ret, int op_errno, gf_dirent_t *entries,
                      dict_t *xdata)
 {
-        gf_dirent_t    *entry = NULL;
-        marker_conf_t  *priv  = NULL;
-        marker_local_t *local = NULL;
-        loc_t           loc   = {0, };
-        int             ret   = -1;
-        char           *resolvedpath = NULL;
+        gf_dirent_t        *entry         = NULL;
+        marker_conf_t      *priv          = NULL;
+        marker_local_t     *local         = NULL;
+        loc_t               loc           = {0, };
+        int                 ret           = -1;
+        char               *resolvedpath  = NULL;
+        quota_inode_ctx_t  *ctx           = NULL;
 
         if (op_ret <= 0)
                 goto unwind;
@@ -3005,6 +3057,11 @@ marker_readdirp_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
                 loc.path = resolvedpath;
                 resolvedpath = NULL;
 
+                ctx = mq_inode_ctx_new (loc.inode, this);
+                if (ctx == NULL)
+                        gf_log (this->name, GF_LOG_WARNING, "mq_inode_ctx_new "
+                                "failed for %s", uuid_utoa (loc.inode->gfid));
+
                 mq_xattr_state (this, &loc, entry->dict, entry->d_stat);
                 loc_wipe (&loc);
 
-- 
1.7.1

