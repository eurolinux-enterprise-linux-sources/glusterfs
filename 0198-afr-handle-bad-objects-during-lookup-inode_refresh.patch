From fa751250fa6c71c6e615dd312c360aa657ed6826 Mon Sep 17 00:00:00 2001
From: Ravishankar N <ravishankar@redhat.com>
Date: Sat, 12 Dec 2015 11:49:20 +0530
Subject: [PATCH 198/214] afr: handle bad objects during lookup/inode_refresh

Patch in upstream: http://review.gluster.org/#/c/12955/

If an object (file) is marked bad by bitrot, do not consider the brick
on which the object is present  as a potential read subvolume for AFR
irrespective of the pending xattr values.

Also do not consider the brick containing the bad object while
performing afr_accuse_smallfiles(). Otherwise if the bad object's size
is bigger, we may end up considering that as the source.

Change-Id: I4abc68e51e5c43c5adfa56e1c00b46db22c88cf7
BUG: 1289228
Signed-off-by: Ravishankar N <ravishankar@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/64239
Reviewed-by: Pranith Kumar Karampuri <pkarampu@redhat.com>
Tested-by: Pranith Kumar Karampuri <pkarampu@redhat.com>
---
 xlators/cluster/afr/src/afr-common.c             |   11 ++++-
 xlators/features/bit-rot/src/stub/bit-rot-stub.c |   57 ++++++++++++++++++++++
 2 files changed, 67 insertions(+), 1 deletions(-)

diff --git a/xlators/cluster/afr/src/afr-common.c b/xlators/cluster/afr/src/afr-common.c
index 0d0270a..0eb2509 100644
--- a/xlators/cluster/afr/src/afr-common.c
+++ b/xlators/cluster/afr/src/afr-common.c
@@ -642,6 +642,8 @@ afr_accuse_smallfiles (xlator_t *this, struct afr_reply *replies,
 	priv = this->private;
 
 	for (i = 0; i < priv->child_count; i++) {
+                if (dict_get (replies[i].xdata, GLUSTERFS_BAD_INODE))
+                        continue;
 		if (data_accused[i])
 			continue;
 		if (replies[i].poststat.ia_size > maxsize)
@@ -703,6 +705,12 @@ afr_replies_interpret (call_frame_t *frame, xlator_t *this, inode_t *inode)
 			continue;
 		}
 
+                if (dict_get (replies[i].xdata, GLUSTERFS_BAD_INODE)) {
+			data_readable[i] = 0;
+			metadata_readable[i] = 0;
+			continue;
+                }
+
 		afr_accused_fill (this, replies[i].xdata, data_accused,
 				  (replies[i].poststat.ia_type == IA_IFDIR) ?
 				   AFR_ENTRY_TRANSACTION : AFR_DATA_TRANSACTION);
@@ -861,7 +869,8 @@ afr_inode_refresh_subvol_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
 		local->replies[call_child].poststat = *buf;
 		if (par)
                         local->replies[call_child].postparent = *par;
-		local->replies[call_child].xdata = dict_ref (xdata);
+                if (xdata)
+		        local->replies[call_child].xdata = dict_ref (xdata);
 	}
         if (xdata) {
                 ret = dict_get_int8 (xdata, "link-count", &need_heal);
diff --git a/xlators/features/bit-rot/src/stub/bit-rot-stub.c b/xlators/features/bit-rot/src/stub/bit-rot-stub.c
index 7f455f2..50f23b5 100644
--- a/xlators/features/bit-rot/src/stub/bit-rot-stub.c
+++ b/xlators/features/bit-rot/src/stub/bit-rot-stub.c
@@ -2768,6 +2768,62 @@ br_stub_lookup (call_frame_t *frame,
 
 /** {{{ */
 
+/* fstat() */
+int br_stub_fstat_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
+                       int32_t op_ret, int32_t op_errno, struct iatt *buf,
+                       dict_t *xdata)
+{
+
+        int              ret    = 0;
+        br_stub_local_t *local  = NULL;
+        inode_t         *inode  = NULL;
+
+        local = frame->local;
+        frame->local = NULL;
+        inode = local->u.context.inode;
+
+        ret = br_stub_mark_xdata_bad_object (this, inode, xdata);
+        if (ret) {
+                op_ret = -1;
+                op_errno = EIO;
+        }
+
+        br_stub_cleanup_local(local);
+        br_stub_dealloc_local(local);
+        STACK_UNWIND_STRICT (fstat, frame, op_ret, op_errno, buf, xdata);
+        return 0;
+}
+
+int
+br_stub_fstat (call_frame_t *frame, xlator_t *this, fd_t *fd, dict_t *xdata)
+{
+        br_stub_local_t *local    = NULL;
+        int32_t          op_ret   = -1;
+        int32_t          op_errno = EINVAL;
+
+        local = br_stub_alloc_local (this);
+        if (!local) {
+                op_ret = -1;
+                op_errno = ENOMEM;
+                goto unwind;
+        }
+
+        br_stub_fill_local (local, NULL, fd, fd->inode, fd->inode->gfid,
+                            BR_STUB_NO_VERSIONING, 0);
+        frame->local = local;
+
+        STACK_WIND (frame, br_stub_fstat_cbk, FIRST_CHILD(this),
+                    FIRST_CHILD(this)->fops->fstat, fd, xdata);
+        return 0;
+unwind:
+        STACK_UNWIND_STRICT (fstat, frame, op_ret, op_errno, NULL, NULL);
+        return 0;
+}
+
+/** }}} */
+
+/** {{{ */
+
 /* forget() */
 
 int
@@ -3042,6 +3098,7 @@ unblock:
 
 struct xlator_fops fops = {
         .lookup    = br_stub_lookup,
+        .fstat     = br_stub_fstat,
         .open      = br_stub_open,
         .create    = br_stub_create,
         .readdirp  = br_stub_readdirp,
-- 
1.7.1

