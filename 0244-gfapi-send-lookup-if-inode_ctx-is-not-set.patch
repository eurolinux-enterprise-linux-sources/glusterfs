From bf8df3ca878381a02a3298062d526ca3ae934622 Mon Sep 17 00:00:00 2001
From: Mohammed Rafi KC <rkavunga@redhat.com>
Date: Tue, 12 Jan 2016 15:04:46 +0530
Subject: [PATCH 244/245] gfapi: send lookup if inode_ctx is not set

Backport of>http://review.gluster.org/#/c/13226/

During resolving of an entry or inode, if inode ctx
was not set, we will send a lookup to pupulate inode
ctx for every xlators

This patch also make sure that inode_ctx will be created
after every inode_link. We will store inode_ctx value as
LOOKUP_NEEDED if the inode is liked via readdirp, in all
other case we will store inode_ctx value as LOOKUP_NOT_NEEDED.

Change-Id: Ie70193cd0b18565311f1dc2b31a79a7e9e2426aa
BUG: 1296048
Signed-off-by: Mohammed Rafi KC <rkavunga@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/65469
Reviewed-by: Dan Lambright <dlambrig@redhat.com>
Tested-by: Dan Lambright <dlambrig@redhat.com>
---
 api/src/glfs-fops.c      |    2 ++
 api/src/glfs-handleops.c |    8 ++++++--
 api/src/glfs-resolve.c   |   13 ++++++++++---
 3 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/api/src/glfs-fops.c b/api/src/glfs-fops.c
index dd9bece..ff55bf3 100644
--- a/api/src/glfs-fops.c
+++ b/api/src/glfs-fops.c
@@ -77,6 +77,7 @@ glfs_loc_link (loc_t *loc, struct iatt *iatt)
 {
 	int ret = -1;
         inode_t *old_inode = NULL;
+        uint64_t ctx_value = LOOKUP_NOT_NEEDED;
 
 	if (!loc->inode) {
 		errno = EINVAL;
@@ -91,6 +92,7 @@ glfs_loc_link (loc_t *loc, struct iatt *iatt)
          */
 	loc->inode = inode_link (loc->inode, loc->parent, loc->name, iatt);
 	if (loc->inode) {
+                inode_ctx_set (loc->inode, THIS, &ctx_value);
 		inode_lookup (loc->inode);
                 inode_unref (old_inode);
 		ret = 0;
diff --git a/api/src/glfs-handleops.c b/api/src/glfs-handleops.c
index e8fbae4..4cfa5e9 100644
--- a/api/src/glfs-handleops.c
+++ b/api/src/glfs-handleops.c
@@ -1269,6 +1269,7 @@ pub_glfs_h_create_from_handle (struct glfs *fs, unsigned char *handle, int len,
         inode_t            *newinode = NULL;
         xlator_t           *subvol = NULL;
         struct glfs_object *object = NULL;
+        uint64_t            ctx_value = LOOKUP_NOT_NEEDED;
 
         /* validate in args */
         if ((fs == NULL) || (handle == NULL) || (len != GFAPI_HANDLE_LENGTH)) {
@@ -1317,9 +1318,12 @@ pub_glfs_h_create_from_handle (struct glfs *fs, unsigned char *handle, int len,
         }
 
         newinode = inode_link (loc.inode, 0, 0, &iatt);
-        if (newinode)
+        if (newinode) {
+                if (newinode == loc.inode) {
+                        inode_ctx_set (newinode, THIS, &ctx_value);
+                }
                 inode_lookup (newinode);
-        else {
+        } else {
                 gf_msg (subvol->name, GF_LOG_WARNING, EINVAL,
                         API_MSG_INVALID_ENTRY,
                         "inode linking of %s failed: %s",
diff --git a/api/src/glfs-resolve.c b/api/src/glfs-resolve.c
index b5efcba..f893332 100644
--- a/api/src/glfs-resolve.c
+++ b/api/src/glfs-resolve.c
@@ -91,6 +91,7 @@ glfs_refresh_inode_safe (xlator_t *subvol, inode_t *oldinode,
 	struct iatt  iatt = {0, };
 	inode_t     *newinode = NULL;
         gf_boolean_t lookup_needed = _gf_false;
+        uint64_t     ctx_value = LOOKUP_NOT_NEEDED;
 
 
 	if (!oldinode)
@@ -129,8 +130,11 @@ glfs_refresh_inode_safe (xlator_t *subvol, inode_t *oldinode,
 	}
 
 	newinode = inode_link (loc.inode, 0, 0, &iatt);
-	if (newinode)
-		inode_lookup (newinode);
+        if (newinode) {
+                if (newinode == loc.inode)
+                        inode_ctx_set (newinode, THIS, &ctx_value);
+                inode_lookup (newinode);
+        }
 
 	loc_wipe (&loc);
 
@@ -240,6 +244,7 @@ glfs_resolve_component (struct glfs *fs, xlator_t *subvol, inode_t *parent,
 	struct iatt  ciatt = {0, };
 	uuid_t       gfid;
 	dict_t      *xattr_req = NULL;
+        uint64_t     ctx_value = LOOKUP_NOT_NEEDED;
 
 	loc.name = component;
 
@@ -270,7 +275,7 @@ glfs_resolve_component (struct glfs *fs, xlator_t *subvol, inode_t *parent,
 		gf_uuid_copy (loc.gfid, loc.inode->gfid);
 		reval = 1;
 
-		if (!force_lookup) {
+                if (!(force_lookup || inode_needs_lookup (loc.inode, THIS))) {
 			inode = inode_ref (loc.inode);
 			ciatt.ia_type = inode->ia_type;
 			goto found;
@@ -341,6 +346,8 @@ glfs_resolve_component (struct glfs *fs, xlator_t *subvol, inode_t *parent,
 		goto out;
 
 	inode = inode_link (loc.inode, loc.parent, component, &ciatt);
+        if (inode == loc.inode)
+                inode_ctx_set (inode, THIS, &ctx_value);
 found:
 	if (inode)
 		inode_lookup (inode);
-- 
1.7.1

