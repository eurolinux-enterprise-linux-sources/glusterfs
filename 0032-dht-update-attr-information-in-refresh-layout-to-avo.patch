From 029b4109de7090f9269a22327203aa1724e15bd4 Mon Sep 17 00:00:00 2001
From: Sakshi Bansal <sabansal@redhat.com>
Date: Sat, 19 Mar 2016 10:15:24 +0530
Subject: [PATCH 32/80] dht: update attr information in refresh layout to avoid
      stale timestamp

Consider the scenario where an mkdir has just created the
directory but has not healed it yet. A parallel lookup on
this entry will find anomalies and trigger a selfheal which
will sample the ctime of the directory after the mkdir phase.
Meanwhile the mkdir has completed setting the layout and
updated the ctime. The selfheal then sees the layout to be
healed and returns with the ctime it got after the mkdir phase
which has now become stale. However if the lookup happens
to unwind before the mkdir then the inode associated with
lookup will get linked in the inode table which has the
stale ctime. To avoid this selfheal must do an iatt_merge in
refresh layout to get the latest timestamp irrespective of
whether it needs to heal the layout or not.

Change-Id: I3634c3978bcc1710705f44b48f3876601682d33e
BUG: 1298724
Signed-off-by: Sakshi Bansal <sabansal@redhat.com>
Reviewed-on: http://review.gluster.org/13781
Smoke: Gluster Build System <jenkins@build.gluster.com>
Reviewed-by: Raghavendra G <rgowdapp@redhat.com>
NetBSD-regression: NetBSD Build System <jenkins@build.gluster.org>
CentOS-regression: Gluster Build System <jenkins@build.gluster.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/70836
Reviewed-by: Raghavendra Gowdappa <rgowdapp@redhat.com>
Tested-by: Raghavendra Gowdappa <rgowdapp@redhat.com>
---
 xlators/cluster/dht/src/dht-selfheal.c |    9 ++++++++-
 1 files changed, 8 insertions(+), 1 deletions(-)

diff --git a/xlators/cluster/dht/src/dht-selfheal.c b/xlators/cluster/dht/src/dht-selfheal.c
index 73e3782..fd55303 100644
--- a/xlators/cluster/dht/src/dht-selfheal.c
+++ b/xlators/cluster/dht/src/dht-selfheal.c
@@ -196,6 +196,8 @@ dht_refresh_layout_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
                 op_ret = dht_layout_merge (this, layout, prev->this,
                                            op_ret, op_errno, xattr);
 
+                dht_iatt_merge (this, &local->stbuf, stbuf, prev->this);
+
                 if (op_ret == -1) {
                         local->op_errno = op_errno;
                         gf_msg_debug (this->name, op_errno,
@@ -642,7 +644,12 @@ dht_selfheal_dir_xattr_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
                 }
         }
 
-        dht_iatt_merge (this, &local->stbuf, stbuf, prev->this);
+        LOCK (&frame->lock);
+        {
+                dht_iatt_merge (this, &local->stbuf, stbuf, prev->this);
+        }
+        UNLOCK (&frame->lock);
+
         this_call_cnt = dht_frame_return (frame);
 
         if (is_last_call (this_call_cnt)) {
-- 
1.7.1

