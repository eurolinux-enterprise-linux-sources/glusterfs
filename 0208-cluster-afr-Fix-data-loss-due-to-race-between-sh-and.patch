From 6cb7e119f9a4b9bc013e7feb7d0db0a36dd4a169 Mon Sep 17 00:00:00 2001
From: Krutika Dhananjay <kdhananj@redhat.com>
Date: Thu, 17 Dec 2015 17:41:08 +0530
Subject: [PATCH 208/214] cluster/afr: Fix data loss due to race between sh and ongoing write

        Backport of: http://review.gluster.org/13036

Problem:

When IO is happening on a file and a brick goes down comes back up
during this time, protocol/client translator attempts reopening of the
fd on the gfid handle of the file. But if another client renames this
file while a brick was down && writes were in progress on it, once this
brick is back up, there can be a race between reopening of the fd and
entry self-heal replaying the effect of the rename() on the sink brick.
If the reopening of the fd happens first, the application's writes
continue to go into the data blocks associated with the gfid.
Now entry-self-heal deletes 'src' and creates 'dst' file on the sink,
marking dst as a 'newentry'.  Data self-heal is also completed on 'dst'
as a result and self-heal terminates. If at this point the application
is still writing to this fd, all writes on the file after self-heal
would go into the data blocks associated with this fd, which would be
lost once the fd is closed. The result - the 'dst' file on the source
and sink are not the same and there is no pending heal on the file,
leading to silent corruption on the sink.

Fix:

Leverage http://review.gluster.org/#/c/12816/ to ensure the gfid handle
path gets saved in .glusterfs/unlink until the fd is closed on the file.
During this time, when self-heal sends mknod() with gfid of the file,
do the following:
link() the gfid handle under .glusterfs/unlink to the new path to be
created in mknod() and
rename() the gfid handle to go back under .glusterfs/ab/cd/.

Change-Id: I3f8d5d8d490f4d241b5fd51191cfebfac6eb8f2c
BUG: 1293240
Signed-off-by: Krutika Dhananjay <kdhananj@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/64347
Reviewed-by: Ravishankar Narayanankutty <ravishankar@redhat.com>
Tested-by: Ravishankar Narayanankutty <ravishankar@redhat.com>
---
 tests/bugs/replicate/bug-1292379.t       |   57 ++++++++++++++++++++++++++++++
 xlators/storage/posix/src/posix-handle.c |   53 ++++++++++++++++++++++++---
 xlators/storage/posix/src/posix-handle.h |    2 +-
 xlators/storage/posix/src/posix.c        |    3 +-
 4 files changed, 107 insertions(+), 8 deletions(-)
 create mode 100644 tests/bugs/replicate/bug-1292379.t

diff --git a/tests/bugs/replicate/bug-1292379.t b/tests/bugs/replicate/bug-1292379.t
new file mode 100644
index 0000000..f086502
--- /dev/null
+++ b/tests/bugs/replicate/bug-1292379.t
@@ -0,0 +1,57 @@
+#!/bin/bash
+
+. $(dirname $0)/../../include.rc
+. $(dirname $0)/../../volume.rc
+. $(dirname $0)/../../afr.rc
+. $(dirname $0)/../../fileio.rc
+
+cleanup
+
+TEST glusterd
+TEST pidof glusterd
+TEST $CLI volume info
+
+TEST $CLI volume create $V0 replica 2 $H0:$B0/${V0}{0,1}
+TEST $CLI volume start $V0
+EXPECT 'Started' volinfo_field $V0 'Status'
+TEST $CLI volume set $V0 cluster.self-heal-daemon off
+TEST $CLI volume set $V0 cluster.entry-self-heal off
+TEST $CLI volume set $V0 cluster.data-self-heal off
+TEST $CLI volume set $V0 cluster.metadata-self-heal off
+TEST $CLI volume set $V0 cluster.eager-lock off
+
+TEST glusterfs --volfile-id=$V0 --volfile-server=$H0 $M0
+
+TEST wfd=`fd_available`
+TEST fd_open $wfd "w" $M0/a
+
+TEST fd_write $wfd "abcd"
+
+# Kill brick-0
+TEST kill_brick $V0 $H0 $B0/${V0}0
+
+# While brick-0 is down, rename 'a' to 'b'
+TEST mv $M0/a $M0/b
+
+TEST fd_write $wfd "lmn"
+
+TEST $CLI volume start $V0 force
+EXPECT_WITHIN $CHILD_UP_TIMEOUT "1" afr_child_up_status $V0 0
+TEST fd_write $wfd "pqrs"
+TEST $CLI volume set $V0 self-heal-daemon on
+EXPECT_WITHIN $CHILD_UP_TIMEOUT "1" afr_child_up_status_in_shd $V0 0
+EXPECT_WITHIN $CHILD_UP_TIMEOUT "1" afr_child_up_status_in_shd $V0 1
+
+TEST $CLI volume heal $V0
+
+EXPECT_WITHIN $HEAL_TIMEOUT "^0$" get_pending_heal_count $V0
+
+TEST fd_write $wfd "xyz"
+TEST fd_close $wfd
+
+md5sum_b0=$(md5sum $B0/${V0}0/b | awk '{print $1}')
+
+EXPECT "$md5sum_b0" echo `md5sum $B0/${V0}1/b | awk '{print $1}'`
+
+TEST umount $M0
+cleanup
diff --git a/xlators/storage/posix/src/posix-handle.c b/xlators/storage/posix/src/posix-handle.c
index 4aee2c1..444b288 100644
--- a/xlators/storage/posix/src/posix-handle.c
+++ b/xlators/storage/posix/src/posix-handle.c
@@ -898,12 +898,18 @@ posix_handle_unset (xlator_t *this, uuid_t gfid, const char *basename)
 
 
 int
-posix_create_link_if_gfid_exists (xlator_t *this, uuid_t gfid,
-                                  char *real_path)
+posix_create_link_if_gfid_exists (xlator_t *this, uuid_t gfid, char *real_path,
+                                  inode_table_t *itable)
 {
-        int ret = -1;
-        struct stat stbuf = {0,};
-        char *newpath = NULL;
+        int                    ret         = -1;
+        char                  *newpath     = NULL;
+        char                  *unlink_path = NULL;
+        uint64_t               ctx_int     = 0;
+        inode_t               *inode       = NULL;
+        struct stat            stbuf       = {0,};
+        struct posix_private  *priv        = NULL;
+
+        priv = this->private;
 
         MAKE_HANDLE_PATH (newpath, this, gfid, NULL);
         if (!newpath) {
@@ -913,9 +919,44 @@ posix_create_link_if_gfid_exists (xlator_t *this, uuid_t gfid,
                 return ret;
         }
 
-        ret = lstat (newpath, &stbuf);
+        ret = sys_lstat (newpath, &stbuf);
         if (!ret) {
                 ret = sys_link (newpath, real_path);
+        } else {
+                inode = inode_find (itable, gfid);
+                if (!inode)
+                        return -1;
+
+                LOCK (&inode->lock);
+                {
+                        ret = __inode_ctx_get0 (inode, this, &ctx_int);
+                        if (ret)
+                                goto unlock;
+
+                        if (ctx_int != GF_UNLINK_TRUE)
+                                goto unlock;
+
+                        POSIX_GET_FILE_UNLINK_PATH (priv->base_path, gfid,
+                                                    unlink_path);
+                        ret = sys_link (unlink_path, real_path);
+                        if (ret) {
+                                gf_msg (this->name, GF_LOG_WARNING, errno,
+                                        P_MSG_HANDLE_CREATE, "Failed to link "
+                                        "%s with %s", real_path, unlink_path);
+                                goto unlock;
+                        }
+                        ret = sys_rename (unlink_path, newpath);
+                        if (ret) {
+                                gf_msg (this->name, GF_LOG_WARNING, errno,
+                                        P_MSG_HANDLE_CREATE, "Failed to link "
+                                        "%s with %s", real_path, unlink_path);
+                                goto unlock;
+                        }
+                        ctx_int = GF_UNLINK_FALSE;
+                        ret = __inode_ctx_set0 (inode, this, &ctx_int);
+                }
+unlock:
+                UNLOCK (&inode->lock);
         }
 
         return ret;
diff --git a/xlators/storage/posix/src/posix-handle.h b/xlators/storage/posix/src/posix-handle.h
index 76ef854..b411908 100644
--- a/xlators/storage/posix/src/posix-handle.h
+++ b/xlators/storage/posix/src/posix-handle.h
@@ -286,7 +286,7 @@ int posix_handle_mkdir_hashes (xlator_t *this, const char *newpath);
 int posix_handle_init (xlator_t *this);
 
 int posix_create_link_if_gfid_exists (xlator_t *this, uuid_t gfid,
-                                      char *real_path);
+                                      char *real_path, inode_table_t *itable);
 
 int
 posix_handle_trash_init (xlator_t *this);
diff --git a/xlators/storage/posix/src/posix.c b/xlators/storage/posix/src/posix.c
index 9cb5a6d..3eb2ea2 100644
--- a/xlators/storage/posix/src/posix.c
+++ b/xlators/storage/posix/src/posix.c
@@ -1186,7 +1186,8 @@ posix_mknod (call_frame_t *frame, xlator_t *this,
                         goto real_op;
                 }
                 op_ret = posix_create_link_if_gfid_exists (this, uuid_req,
-                                                           real_path);
+                                                           real_path,
+                                                           loc->inode->table);
                 if (!op_ret) {
                         linked = _gf_true;
                         goto post_op;
-- 
1.7.1

