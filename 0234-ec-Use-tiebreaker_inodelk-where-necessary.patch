From ecbb79d192695e06345036aa4f24e0f029ce8b02 Mon Sep 17 00:00:00 2001
From: Pranith Kumar K <pkarampu@redhat.com>
Date: Fri, 17 Nov 2017 07:20:21 +0530
Subject: [PATCH 234/236] ec: Use tiebreaker_inodelk where necessary

When there are big directories or files that need to be healed,
other shds are stuck on getting lock on self-heal domain for these
directories/files. If there is a tie-breaker logic, other shds
can heal some other files/directories while 1 of the shds is healing
the big file/directory.

Before this patch:
96.67  4890.64 us 12.89 us 646115887.30us 340869 INODELK
After this patch:
40.76  42.35 us   15.09 us 6546.50us 438478 INODELK

 >Fixes gluster/glusterfs#354

Upstream-patch: https://review.gluster.org/18820
BUG: 1562744
Change-Id: Ia995b5576b44f770c064090705c78459e543cc64
Signed-off-by: Pranith Kumar K <pkarampu@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/134280
Tested-by: RHGS Build Bot <nigelb@redhat.com>
Reviewed-by: Ashish Pandey <aspandey@redhat.com>
---
 xlators/cluster/ec/src/ec-heal.c | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/xlators/cluster/ec/src/ec-heal.c b/xlators/cluster/ec/src/ec-heal.c
index 8e02986..a1d3f3d 100644
--- a/xlators/cluster/ec/src/ec-heal.c
+++ b/xlators/cluster/ec/src/ec-heal.c
@@ -1562,9 +1562,9 @@ ec_heal_entry (call_frame_t *frame, ec_t *ec, inode_t *inode,
         sprintf (selfheal_domain, "%s:self-heal", ec->xl->name);
         ec_mask_to_char_array (ec->xl_up, up_subvols, ec->nodes);
         /*If other processes are already doing the heal, don't block*/
-        ret = cluster_inodelk (ec->xl_list, up_subvols, ec->nodes, replies,
-                               locked_on, frame, ec->xl, selfheal_domain, inode,
-                               0, 0);
+        ret = cluster_tiebreaker_inodelk (ec->xl_list, up_subvols, ec->nodes,
+                                          replies, locked_on, frame, ec->xl,
+                                          selfheal_domain, inode, 0, 0);
         {
                 if (ret <= ec->fragments) {
                         gf_msg_debug (ec->xl->name, 0, "%s: Skipping heal "
@@ -2400,9 +2400,10 @@ ec_heal_data (call_frame_t *frame, ec_t *ec, gf_boolean_t block, inode_t *inode,
                                        locked_on, frame, ec->xl,
                                        selfheal_domain, inode, 0, 0);
         } else {
-                ret = cluster_tryinodelk (ec->xl_list, output, ec->nodes,
-                                          replies, locked_on, frame, ec->xl,
-                                          selfheal_domain, inode, 0, 0);
+                ret = cluster_tiebreaker_inodelk (ec->xl_list, output,
+                                                  ec->nodes, replies, locked_on,
+                                                  frame, ec->xl,
+                                                  selfheal_domain, inode, 0, 0);
         }
         {
                 if (ret <= ec->fragments) {
@@ -2453,8 +2454,10 @@ ec_heal_do (xlator_t *this, void *data, loc_t *loc, int32_t partial)
 
         /* If it is heal request from getxattr, complete the heal and then
          * unwind, if it is ec_heal with NULL as frame then no need to block
-         * the heal as the caller doesn't care about its completion*/
-        if (fop->req_frame)
+         * the heal as the caller doesn't care about its completion. In case
+         * of heald whichever gets tiebreaking inodelk will take care of the
+         * heal, so no need to block*/
+        if (fop->req_frame && !ec->shd.iamshd)
                 blocking = _gf_true;
 
         frame = create_frame (this, this->ctx->pool);
-- 
1.8.3.1

