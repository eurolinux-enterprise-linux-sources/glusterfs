From 49d774b8af83b18b13978e871ada999c9d443292 Mon Sep 17 00:00:00 2001
From: Mohammed Rafi KC <rkavunga@redhat.com>
Date: Wed, 12 Aug 2015 14:30:27 +0530
Subject: [PATCH 242/245] fuse:sent at least one lookup before actual fop

Backport of>http://review.gluster.org/#/c/11892/

Fuse shoud sent atleast one lookup for an inode/gfid
populated via readdirp before actual fop to populate
inode ctx for xlators

Change-Id: I8d688921b441504f773747b8a8283050ee7c55ea
BUG: 1296048
Signed-off-by: Mohammed Rafi KC <rkavunga@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/65467
Reviewed-by: Dan Lambright <dlambrig@redhat.com>
Tested-by: Dan Lambright <dlambrig@redhat.com>
---
 xlators/mount/fuse/src/fuse-resolve.c |   20 ++++++++++++++++++--
 1 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/xlators/mount/fuse/src/fuse-resolve.c b/xlators/mount/fuse/src/fuse-resolve.c
index a670f4f..3267d37 100644
--- a/xlators/mount/fuse/src/fuse-resolve.c
+++ b/xlators/mount/fuse/src/fuse-resolve.c
@@ -93,8 +93,12 @@ fuse_resolve_entry (fuse_state_t *state)
 	resolve_loc->parent = inode_ref (state->loc_now->parent);
 	gf_uuid_copy (resolve_loc->pargfid, state->loc_now->pargfid);
         resolve_loc->name = resolve->bname;
-        resolve_loc->inode = inode_new (state->itable);
 
+        resolve_loc->inode = inode_grep (state->itable, resolve->parhint,
+                                         resolve->bname);
+        if (!resolve_loc->inode) {
+                resolve_loc->inode = inode_new (state->itable);
+        }
         inode_path (resolve_loc->parent, resolve_loc->name,
                     (char **) &resolve_loc->path);
 
@@ -113,7 +117,8 @@ fuse_resolve_gfid_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
         fuse_state_t   *state      = NULL;
         fuse_resolve_t *resolve    = NULL;
         inode_t        *link_inode = NULL;
-        loc_t          *loc_now   = NULL;
+        loc_t          *loc_now    = NULL;
+        inode_t        *tmp_inode  = NULL;
 
         state = frame->root->state;
         resolve = state->resolve_now;
@@ -160,6 +165,13 @@ fuse_resolve_gfid_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
 	loc_now->parent = link_inode;
         gf_uuid_copy (loc_now->pargfid, link_inode->gfid);
 
+        tmp_inode = inode_grep (state->itable, link_inode, resolve->bname);
+        if (tmp_inode && (!inode_needs_lookup (tmp_inode, THIS))) {
+                loc_now->inode = tmp_inode;
+                goto out;
+        }
+
+        inode_unref (tmp_inode);
 	fuse_resolve_entry (state);
 
         return 0;
@@ -241,6 +253,10 @@ fuse_resolve_parent_simple (fuse_state_t *state)
                  * we took the conservative approach of assuming entry should
                  * have been there even though it need not have (bug #804592).
                  */
+
+                if (loc->inode && inode_needs_lookup (loc->inode, THIS))
+                        return -1;
+
                 if ((loc->inode == NULL)
                     && __is_root_gfid (parent->gfid)) {
                         /* non decisive result - entry missing */
-- 
1.7.1

