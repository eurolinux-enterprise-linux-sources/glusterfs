From a4a8a68a7f884e6cfd52fcf2733bdf339fa4a289 Mon Sep 17 00:00:00 2001
From: vmallika <vmallika@redhat.com>
Date: Sat, 2 Apr 2016 08:57:00 +0530
Subject: [PATCH 57/80] marker: optimize mq_update_dirty_inode_task

This is a backport of http://review.gluster.org/13892

In function mq_update_dirty_inode_task we do readdirp
on a dirty directory and for entry we again do
lookup to fecth the contribution xattr.
We can fetch this contribution as part of readdirp

> Change-Id: I766593c0dba793f1ab3b43625acce1c7d9af8d7f
> BUG: 1320818
> Signed-off-by: vmallika <vmallika@redhat.com>
> Reviewed-on: http://review.gluster.org/13892
> NetBSD-regression: NetBSD Build System <jenkins@build.gluster.org>
> CentOS-regression: Gluster Build System <jenkins@build.gluster.com>
> Smoke: Gluster Build System <jenkins@build.gluster.com>
> Reviewed-by: Manikandan Selvaganesh <mselvaga@redhat.com>

Change-Id: I289886de9a203431aee7a0cc06be986136d44506
BUG: 1318170
Signed-off-by: vmallika <vmallika@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/71540
Reviewed-by: Raghavendra Gowdappa <rgowdapp@redhat.com>
Tested-by: Raghavendra Gowdappa <rgowdapp@redhat.com>
---
 libglusterfs/src/quota-common-utils.c      |   11 +++
 libglusterfs/src/quota-common-utils.h      |    3 +
 xlators/features/marker/src/marker-quota.c |   94 +++++++++++++---------------
 3 files changed, 58 insertions(+), 50 deletions(-)

diff --git a/libglusterfs/src/quota-common-utils.c b/libglusterfs/src/quota-common-utils.c
index 5e688e5..ad7e4dc 100644
--- a/libglusterfs/src/quota-common-utils.c
+++ b/libglusterfs/src/quota-common-utils.c
@@ -16,6 +16,17 @@
 #include "common-utils.h"
 #include "libglusterfs-messages.h"
 
+gf_boolean_t
+quota_meta_is_null (const quota_meta_t *meta)
+{
+        if (meta->size == 0 &&
+            meta->file_count == 0 &&
+            meta->dir_count == 0)
+                return _gf_true;
+
+        return _gf_false;
+}
+
 int32_t
 quota_data_to_meta (data_t *data, char *key, quota_meta_t *meta)
 {
diff --git a/libglusterfs/src/quota-common-utils.h b/libglusterfs/src/quota-common-utils.h
index c930db8..e479398 100644
--- a/libglusterfs/src/quota-common-utils.h
+++ b/libglusterfs/src/quota-common-utils.h
@@ -37,6 +37,9 @@ struct _quota_meta {
 } __attribute__ ((__packed__));
 typedef struct _quota_meta quota_meta_t;
 
+gf_boolean_t
+quota_meta_is_null (const quota_meta_t *meta);
+
 int32_t
 quota_data_to_meta (data_t *data, char *key, quota_meta_t *meta);
 
diff --git a/xlators/features/marker/src/marker-quota.c b/xlators/features/marker/src/marker-quota.c
index 8b7ce90..e23b769 100644
--- a/xlators/features/marker/src/marker-quota.c
+++ b/xlators/features/marker/src/marker-quota.c
@@ -377,17 +377,6 @@ mq_sub_meta (quota_meta_t *dst, const quota_meta_t *src)
         }
 }
 
-gf_boolean_t
-quota_meta_is_null (const quota_meta_t *meta)
-{
-        if (meta->size == 0 &&
-            meta->file_count == 0 &&
-            meta->dir_count == 0)
-                return _gf_true;
-
-        return _gf_false;
-}
-
 int32_t
 mq_are_xattrs_set (xlator_t *this, loc_t *loc, gf_boolean_t *contri_set,
                    gf_boolean_t *size_set)
@@ -1769,24 +1758,24 @@ out:
 int
 mq_update_dirty_inode_task (void *opaque)
 {
-        int32_t               ret            = -1;
-        fd_t                 *fd             = NULL;
-        off_t                 offset         = 0;
-        loc_t                 child_loc      = {0, };
+        int32_t               ret                         = -1;
+        fd_t                 *fd                          = NULL;
+        off_t                 offset                      = 0;
         gf_dirent_t           entries;
-        gf_dirent_t          *entry          = NULL;
-        gf_boolean_t          locked         = _gf_false;
-        gf_boolean_t          free_entries   = _gf_false;
-        gf_boolean_t          updated        = _gf_false;
-        int32_t               dirty          = 0;
-        quota_meta_t          contri         = {0, };
-        quota_meta_t          size           = {0, };
-        quota_meta_t          contri_sum     = {0, };
-        quota_meta_t          delta          = {0, };
-        quota_synctask_t     *args           = NULL;
-        xlator_t             *this           = NULL;
-        loc_t                *loc            = NULL;
-        quota_inode_ctx_t    *ctx            = NULL;
+        gf_dirent_t          *entry                       = NULL;
+        gf_boolean_t          locked                      = _gf_false;
+        gf_boolean_t          updated                     = _gf_false;
+        int32_t               dirty                       = 0;
+        quota_meta_t          contri                      = {0, };
+        quota_meta_t          size                        = {0, };
+        quota_meta_t          contri_sum                  = {0, };
+        quota_meta_t          delta                       = {0, };
+        quota_synctask_t     *args                        = NULL;
+        xlator_t             *this                        = NULL;
+        loc_t                *loc                         = NULL;
+        quota_inode_ctx_t    *ctx                         = NULL;
+        dict_t               *xdata                       = NULL;
+        char                  contri_key[QUOTA_KEY_MAX]   = {0, };
 
         GF_ASSERT (opaque);
 
@@ -1794,11 +1783,29 @@ mq_update_dirty_inode_task (void *opaque)
         loc = &args->loc;
         this = args->this;
         THIS = this;
+        INIT_LIST_HEAD (&entries.list);
 
         ret = mq_inode_ctx_get (loc->inode, this, &ctx);
         if (ret < 0)
                 goto out;
 
+        GET_CONTRI_KEY (this, contri_key, loc->gfid, ret);
+        if (ret < 0)
+                goto out;
+
+        xdata = dict_new ();
+        if (xdata == NULL) {
+                gf_log (this->name, GF_LOG_ERROR, "dict_new failed");
+                ret = -1;
+                goto out;
+        }
+
+        ret = dict_set_int64 (xdata, contri_key, 0);
+        if (ret < 0) {
+                gf_log (this->name, GF_LOG_ERROR, "dict_set failed");
+                goto out;
+        }
+
         ret = mq_lock (this, loc, F_WRLCK);
         if (ret < 0)
                 goto out;
@@ -1826,9 +1833,8 @@ mq_update_dirty_inode_task (void *opaque)
         }
 
         fd_bind (fd);
-        INIT_LIST_HEAD (&entries.list);
         while ((ret = syncop_readdirp (this, fd, 131072, offset, &entries,
-                                       NULL, NULL)) != 0) {
+                                       xdata, NULL)) != 0) {
                 if (ret < 0) {
                         gf_log (this->name, (-ret == ENOENT || -ret == ESTALE)
                                 ? GF_LOG_DEBUG:GF_LOG_ERROR, "readdirp failed "
@@ -1839,7 +1845,6 @@ mq_update_dirty_inode_task (void *opaque)
                 if (list_empty (&entries.list))
                         break;
 
-                free_entries = _gf_true;
                 list_for_each_entry (entry, &entries.list, list) {
                         offset = entry->d_off;
 
@@ -1847,26 +1852,15 @@ mq_update_dirty_inode_task (void *opaque)
                             !strcmp (entry->d_name, ".."))
                                 continue;
 
-                        ret = loc_build_child (&child_loc, loc, entry->d_name);
-                        if (ret < 0) {
-                                gf_log (this->name, GF_LOG_WARNING,
-                                        "Couldn't build loc for %s/%s "
-                                        "returning from updation of dirty "
-                                        "inode", loc->path, entry->d_name);
-                                goto out;
-                        }
-
-                        ret = mq_get_contri (this, &child_loc, &contri,
-                                             loc->gfid);
-                        if (ret < 0)
-                                goto out;
+                        memset (&contri, 0, sizeof (contri));
+                        quota_dict_get_meta (entry->dict, contri_key, &contri);
+                        if (quota_meta_is_null (&contri))
+                                continue;
 
                         mq_add_meta (&contri_sum, &contri);
-                        loc_wipe (&child_loc);
                 }
 
                 gf_dirent_free (&entries);
-                free_entries = _gf_false;
         }
         /* Inculde for self */
         contri_sum.dir_count++;
@@ -1903,12 +1897,14 @@ mq_update_dirty_inode_task (void *opaque)
         updated = _gf_true;
 
 out:
-        if (free_entries)
-                gf_dirent_free (&entries);
+        gf_dirent_free (&entries);
 
         if (fd)
                 fd_unref (fd);
 
+        if (xdata)
+                dict_unref (xdata);
+
         if (ret < 0) {
                 /* On failure clear dirty status flag.
                  * In the next lookup inspect_directory_xattr
@@ -1924,8 +1920,6 @@ out:
         if (locked)
                 mq_lock (this, loc, F_UNLCK);
 
-        loc_wipe(&child_loc);
-
         if (updated)
                 mq_initiate_quota_blocking_txn (this, loc, NULL);
 
-- 
1.7.1

