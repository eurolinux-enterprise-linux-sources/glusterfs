From b1df47032f00d321b864a32d5542407c53910197 Mon Sep 17 00:00:00 2001
From: Gaurav Kumar Garg <ggarg@redhat.com>
Date: Fri, 30 Oct 2015 20:57:42 +0530
Subject: [PATCH 76/98] Revert "rpc: fix binding brick issue while bind-insecure is enabled"

This commit along with 17f8e37321527c35673d88dc89a79c65054c3a4d
completely reverts 5ebf298ec03bc929a4142e70ed105130cf9c58df

Change-Id: Ic2bb705edd7e61a751dcae4fc4d4f889e622f01b
BUG: 1271999
Signed-off-by: Gaurav Kumar Garg <ggarg@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/60530
Reviewed-by: Raghavendra Talur <rtalur@redhat.com>
Reviewed-by: Raghavendra Gowdappa <rgowdapp@redhat.com>
Tested-by: Raghavendra Gowdappa <rgowdapp@redhat.com>
---
 libglusterfs/src/common-utils.c     |   17 +++++----
 libglusterfs/src/common-utils.h     |    6 +--
 rpc/rpc-transport/rdma/src/name.c   |   67 +++++++++++++++--------------------
 rpc/rpc-transport/socket/src/name.c |   32 ++++++----------
 4 files changed, 52 insertions(+), 70 deletions(-)

diff --git a/libglusterfs/src/common-utils.c b/libglusterfs/src/common-utils.c
index 2ac8cb7..a8430ca 100644
--- a/libglusterfs/src/common-utils.c
+++ b/libglusterfs/src/common-utils.c
@@ -2794,7 +2794,7 @@ out:
 }
 
 int
-gf_process_reserved_ports (gf_boolean_t *ports, uint32_t ceiling)
+gf_process_reserved_ports (gf_boolean_t *ports)
 {
         int      ret         = -1;
 #if defined GF_LINUX_HOST_OS
@@ -2814,7 +2814,7 @@ gf_process_reserved_ports (gf_boolean_t *ports, uint32_t ceiling)
         blocked_port = strtok_r (ports_info, ",\n",&tmp);
 
         while (blocked_port) {
-                gf_ports_reserved (blocked_port, ports, ceiling);
+                gf_ports_reserved (blocked_port, ports);
                 blocked_port = strtok_r (NULL, ",\n", &tmp);
         }
 
@@ -2827,7 +2827,7 @@ out:
 }
 
 gf_boolean_t
-gf_ports_reserved (char *blocked_port, gf_boolean_t *ports, uint32_t ceiling)
+gf_ports_reserved (char *blocked_port, gf_boolean_t *ports)
 {
         gf_boolean_t    result   = _gf_false;
         char            *range_port = NULL;
@@ -2838,7 +2838,7 @@ gf_ports_reserved (char *blocked_port, gf_boolean_t *ports, uint32_t ceiling)
                 if (blocked_port[strlen(blocked_port) -1] == '\n')
                         blocked_port[strlen(blocked_port) -1] = '\0';
                 if (gf_string2int16 (blocked_port, &tmp_port1) == 0) {
-                        if (tmp_port1 > ceiling
+                        if (tmp_port1 > (GF_CLIENT_PORT_CEILING - 1)
                             || tmp_port1 < 0) {
                                 gf_msg ("glusterfs-socket", GF_LOG_WARNING, 0,
                                         LG_MSG_INVALID_PORT, "invalid port %d",
@@ -2864,8 +2864,8 @@ gf_ports_reserved (char *blocked_port, gf_boolean_t *ports, uint32_t ceiling)
                         goto out;
                 }
                 if (gf_string2int16 (range_port, &tmp_port1) == 0) {
-                        if (tmp_port1 > ceiling)
-                                tmp_port1 = ceiling;
+                        if (tmp_port1 > (GF_CLIENT_PORT_CEILING - 1))
+                                tmp_port1 = GF_CLIENT_PORT_CEILING - 1;
                         if (tmp_port1 < 0)
                                 tmp_port1 = 0;
                 }
@@ -2878,8 +2878,9 @@ gf_ports_reserved (char *blocked_port, gf_boolean_t *ports, uint32_t ceiling)
                 if (range_port[strlen(range_port) -1] == '\n')
                         range_port[strlen(range_port) - 1] = '\0';
                 if (gf_string2int16 (range_port, &tmp_port2) == 0) {
-                        if (tmp_port2 > ceiling)
-                                tmp_port2 = ceiling;
+                        if (tmp_port2 >
+                            (GF_CLIENT_PORT_CEILING - 1))
+                                tmp_port2 = GF_CLIENT_PORT_CEILING - 1;
                         if (tmp_port2 < 0)
                                 tmp_port2 = 0;
                 }
diff --git a/libglusterfs/src/common-utils.h b/libglusterfs/src/common-utils.h
index 8edb78b..f3bd924 100644
--- a/libglusterfs/src/common-utils.h
+++ b/libglusterfs/src/common-utils.h
@@ -88,7 +88,6 @@ void trap (void);
  */
 #define GF_NFS3_PORT    2049
 #define GF_CLIENT_PORT_CEILING 1024
-#define GF_PORT_MAX 65535
 
 #define GF_MINUTE_IN_SECONDS 60
 #define GF_HOUR_IN_SECONDS (60*60)
@@ -704,9 +703,8 @@ int gf_strip_whitespace (char *str, int len);
 int gf_canonicalize_path (char *path);
 char *generate_glusterfs_ctx_id (void);
 char *gf_get_reserved_ports();
-int gf_process_reserved_ports (gf_boolean_t ports[], uint32_t ceiling);
-gf_boolean_t
-gf_ports_reserved (char *blocked_port, gf_boolean_t *ports, uint32_t ceiling);
+int gf_process_reserved_ports (gf_boolean_t ports[]);
+gf_boolean_t gf_ports_reserved (char *blocked_port, gf_boolean_t *ports);
 int gf_get_hostname_from_ip (char *client_ip, char **hostname);
 gf_boolean_t gf_is_local_addr (char *hostname);
 gf_boolean_t gf_is_same_address (char *host1, char *host2);
diff --git a/rpc/rpc-transport/rdma/src/name.c b/rpc/rpc-transport/rdma/src/name.c
index 0bbbbc0..88e3925 100644
--- a/rpc/rpc-transport/rdma/src/name.c
+++ b/rpc/rpc-transport/rdma/src/name.c
@@ -33,41 +33,36 @@ gf_resolve_ip6 (const char *hostname,
                 void **dnscache,
                 struct addrinfo **addr_info);
 
-
-static void
-_assign_port (struct sockaddr *sockaddr, uint16_t port)
-{
-        switch (sockaddr->sa_family) {
-        case AF_INET6:
-                ((struct sockaddr_in6 *)sockaddr)->sin6_port = htons (port);
-                break;
-
-        case AF_INET_SDP:
-        case AF_INET:
-                ((struct sockaddr_in *)sockaddr)->sin_port = htons (port);
-                break;
-        }
-}
-
 static int32_t
 af_inet_bind_to_port_lt_ceiling (struct rdma_cm_id *cm_id,
                                  struct sockaddr *sockaddr,
-                                 socklen_t sockaddr_len, uint32_t ceiling)
+                                 socklen_t sockaddr_len, int ceiling)
 {
         int32_t        ret        = -1;
         uint16_t      port        = ceiling - 1;
         /* by default assume none of the ports are blocked and all are available */
-        gf_boolean_t  ports[GF_PORT_MAX] = {_gf_false,};
+        gf_boolean_t  ports[1024] = {_gf_false,};
         int           i           = 0;
 
-        ret = gf_process_reserved_ports (ports, ceiling);
+        ret = gf_process_reserved_ports (ports);
         if (ret != 0) {
-                for (i = 0; i < GF_PORT_MAX; i++)
+                for (i = 0; i < 1024; i++)
                         ports[i] = _gf_false;
         }
 
         while (port) {
-                _assign_port (sockaddr, port);
+                switch (sockaddr->sa_family) {
+                case AF_INET6:
+                        ((struct sockaddr_in6 *)sockaddr)->sin6_port
+                                = htons (port);
+                        break;
+
+                case AF_INET_SDP:
+                case AF_INET:
+                        ((struct sockaddr_in *)sockaddr)->sin_port
+                                = htons (port);
+                        break;
+                }
                 /* ignore the reserved ports */
                 if (ports[port] == _gf_true) {
                         port--;
@@ -431,26 +426,22 @@ gf_rdma_client_bind (rpc_transport_t *this, struct sockaddr *sockaddr,
                 *sockaddr_len = sizeof (struct sockaddr_in);
 
         case AF_INET6:
-                if (!this->bind_insecure) {
-                        ret = af_inet_bind_to_port_lt_ceiling (cm_id, sockaddr,
+                ret = af_inet_bind_to_port_lt_ceiling (cm_id, sockaddr,
                                                        *sockaddr_len,
                                                        GF_CLIENT_PORT_CEILING);
-                        if (ret == -1) {
-                                gf_msg (this->name, GF_LOG_WARNING, errno,
-                                        RDMA_MSG_PORT_BIND_FAILED,
-                                        "cannot bind rdma_cm_id to port "
-                                        "less than %d", GF_CLIENT_PORT_CEILING);
-                        }
-                } else {
-                        ret = af_inet_bind_to_port_lt_ceiling (cm_id, sockaddr,
-                                                       *sockaddr_len,
-                                                       GF_PORT_MAX);
-                        if (ret == -1) {
-                                gf_msg (this->name, GF_LOG_WARNING, errno,
-                                        RDMA_MSG_PORT_BIND_FAILED,
-                                        "cannot bind rdma_cm_id to port "
-                                        "less than %d", GF_PORT_MAX);
+                if (ret == -1) {
+                        gf_msg (this->name, GF_LOG_WARNING, errno,
+                                RDMA_MSG_PORT_BIND_FAILED,
+                                "cannot bind rdma_cm_id to port "
+                                "less than %d", GF_CLIENT_PORT_CEILING);
+                        if (sockaddr->sa_family == AF_INET6) {
+                                ((struct sockaddr_in6 *)sockaddr)->sin6_port
+                                        = htons (0);
+                        } else {
+                                ((struct sockaddr_in *)sockaddr)->sin_port
+                                        = htons (0);
                         }
+                        ret = rdma_bind_addr (cm_id, sockaddr);
                 }
                 break;
 
diff --git a/rpc/rpc-transport/socket/src/name.c b/rpc/rpc-transport/socket/src/name.c
index a936fa5..f731bab 100644
--- a/rpc/rpc-transport/socket/src/name.c
+++ b/rpc/rpc-transport/socket/src/name.c
@@ -25,23 +25,24 @@
 
 static int32_t
 af_inet_bind_to_port_lt_ceiling (int fd, struct sockaddr *sockaddr,
-                                 socklen_t sockaddr_len, uint32_t ceiling)
+                                 socklen_t sockaddr_len, int ceiling)
 {
         int32_t        ret        = -1;
         uint16_t      port        = ceiling - 1;
         // by default assume none of the ports are blocked and all are available
-        gf_boolean_t  ports[GF_PORT_MAX] = {_gf_false,};
+        gf_boolean_t  ports[1024] = {_gf_false,};
         int           i           = 0;
 
-        ret = gf_process_reserved_ports (ports, ceiling);
+        ret = gf_process_reserved_ports (ports);
         if (ret != 0) {
-                for (i = 0; i < GF_PORT_MAX; i++)
+                for (i = 0; i < 1024; i++)
                         ports[i] = _gf_false;
         }
 
         while (port)
         {
-                switch (sockaddr->sa_family) {
+                switch (sockaddr->sa_family)
+                {
                 case AF_INET6:
                         ((struct sockaddr_in6 *)sockaddr)->sin6_port = htons (port);
                         break;
@@ -439,21 +440,12 @@ client_bind (rpc_transport_t *this,
                 if (!this->bind_insecure) {
                         ret = af_inet_bind_to_port_lt_ceiling (sock, sockaddr,
                                                        *sockaddr_len, GF_CLIENT_PORT_CEILING);
-                        if (ret == -1) {
-                                gf_log (this->name, GF_LOG_DEBUG,
-                                        "cannot bind inet socket (%d) to port less than %d (%s)",
-                                        sock, GF_CLIENT_PORT_CEILING, strerror (errno));
-                                ret = 0;
-                        }
-                } else {
-                        ret = af_inet_bind_to_port_lt_ceiling (sock, sockaddr,
-                                                       *sockaddr_len, GF_PORT_MAX);
-                        if (ret == -1) {
-                                gf_log (this->name, GF_LOG_DEBUG,
-                                        "failed while binding to less than %d (%s)",
-                                        GF_PORT_MAX, strerror (errno));
-                                ret = 0;
-                        }
+                }
+                if (ret == -1) {
+                        gf_log (this->name, GF_LOG_DEBUG,
+                                "cannot bind inet socket (%d) to port less than %d (%s)",
+                                sock, GF_CLIENT_PORT_CEILING, strerror (errno));
+                        ret = 0;
                 }
                 break;
 
-- 
1.7.1

