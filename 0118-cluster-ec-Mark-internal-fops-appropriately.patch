From 943f80b8b4785f5600b6047d3be83b729703eb70 Mon Sep 17 00:00:00 2001
From: Xavier Hernandez <xhernandez@datalab.es>
Date: Tue, 17 Nov 2015 14:06:20 +0100
Subject: [PATCH 118/131] cluster/ec: Mark internal fops appropriately

1) Mark read fops in read-modify-write by EC as internal.
2) Handle uid/gid set/reset correctly

 >BUG: 1282761
 >Change-Id: I5c1ce0cd6213367eaead5fed33aa2397c4e46df7
 >Signed-off-by: Xavier Hernandez <xhernandez@datalab.es>
 >Reviewed-on: http://review.gluster.org/12599
 >Tested-by: Gluster Build System <jenkins@build.gluster.com>
 >Tested-by: NetBSD Build System <jenkins@build.gluster.org>
 >Reviewed-by: Pranith Kumar Karampuri <pkarampu@redhat.com>

BUG: 1278279
Change-Id: I9f039cf3ec6351525fb65381bad44d986595844f
Signed-off-by: Xavier Hernandez <xhernandez@datalab.es>
Reviewed-on: https://code.engineering.redhat.com/gerrit/61928
Reviewed-by: Pranith Kumar Karampuri <pkarampu@redhat.com>
Tested-by: Pranith Kumar Karampuri <pkarampu@redhat.com>
---
 xlators/cluster/ec/src/ec-common.c      |   18 ++-------
 xlators/cluster/ec/src/ec-data.c        |    3 ++
 xlators/cluster/ec/src/ec-data.h        |    3 ++
 xlators/cluster/ec/src/ec-inode-write.c |   61 ++++++++++++++++++++++++-------
 4 files changed, 58 insertions(+), 27 deletions(-)

diff --git a/xlators/cluster/ec/src/ec-common.c b/xlators/cluster/ec/src/ec-common.c
index be2df64..242ba73 100644
--- a/xlators/cluster/ec/src/ec-common.c
+++ b/xlators/cluster/ec/src/ec-common.c
@@ -989,8 +989,6 @@ void ec_get_size_version(ec_lock_link_t *link)
     ec_inode_t *ctx;
     ec_fop_data_t *fop;
     dict_t *dict = NULL;
-    uid_t uid;
-    gid_t gid;
     int32_t error = -ENOMEM;
     uint64_t allzero[EC_VERSION_SIZE] = {0, 0};
 
@@ -1012,9 +1010,6 @@ void ec_get_size_version(ec_lock_link_t *link)
         return;
     }
 
-    uid = fop->frame->root->uid;
-    gid = fop->frame->root->gid;
-
     memset(&loc, 0, sizeof(loc));
 
     dict = dict_new();
@@ -1081,8 +1076,8 @@ void ec_get_size_version(ec_lock_link_t *link)
     error = 0;
 
 out:
-    fop->frame->root->uid = uid;
-    fop->frame->root->gid = gid;
+    fop->frame->root->uid = fop->uid;
+    fop->frame->root->gid = fop->gid;
 
     loc_wipe(&loc);
 
@@ -1566,8 +1561,6 @@ ec_update_size_version(ec_lock_link_t *link, uint64_t *version,
     ec_lock_t *lock;
     ec_inode_t *ctx;
     dict_t * dict;
-    uid_t uid;
-    gid_t gid;
     int32_t err = -ENOMEM;
 
     fop = link->fop;
@@ -1620,9 +1613,6 @@ ec_update_size_version(ec_lock_link_t *link, uint64_t *version,
         ec_dict_set_number(dict, EC_XATTR_CONFIG, 0);
     }
 
-    uid = fop->frame->root->uid;
-    gid = fop->frame->root->gid;
-
     fop->frame->root->uid = 0;
     fop->frame->root->gid = 0;
 
@@ -1636,8 +1626,8 @@ ec_update_size_version(ec_lock_link_t *link, uint64_t *version,
                        GF_XATTROP_ADD_ARRAY64, dict, NULL);
     }
 
-    fop->frame->root->uid = uid;
-    fop->frame->root->gid = gid;
+    fop->frame->root->uid = fop->uid;
+    fop->frame->root->gid = fop->gid;
 
     dict_unref(dict);
 
diff --git a/xlators/cluster/ec/src/ec-data.c b/xlators/cluster/ec/src/ec-data.c
index 3dd1a34..474246e 100644
--- a/xlators/cluster/ec/src/ec-data.c
+++ b/xlators/cluster/ec/src/ec-data.c
@@ -182,6 +182,9 @@ ec_fop_data_t * ec_fop_data_allocate(call_frame_t * frame, xlator_t * this,
     fop->cbks = cbks;
     fop->data = data;
 
+    fop->uid = fop->frame->root->uid;
+    fop->gid = fop->frame->root->gid;
+
     LOCK_INIT(&fop->lock);
 
     fop->frame->local = fop;
diff --git a/xlators/cluster/ec/src/ec-data.h b/xlators/cluster/ec/src/ec-data.h
index d845bf5..090f919 100644
--- a/xlators/cluster/ec/src/ec-data.h
+++ b/xlators/cluster/ec/src/ec-data.h
@@ -205,6 +205,9 @@ struct _ec_fop_data
     uintptr_t          received; /* Mask of responses */
     uintptr_t          good;
 
+    uid_t              uid;
+    gid_t              gid;
+
     ec_wind_f          wind;
     ec_handler_f       handler;
     ec_resume_f        resume;
diff --git a/xlators/cluster/ec/src/ec-inode-write.c b/xlators/cluster/ec/src/ec-inode-write.c
index 50d7108..4bd692d 100644
--- a/xlators/cluster/ec/src/ec-inode-write.c
+++ b/xlators/cluster/ec/src/ec-inode-write.c
@@ -1265,6 +1265,26 @@ int32_t ec_writev_merge_head(call_frame_t * frame, void * cookie,
     return 0;
 }
 
+static int
+ec_make_internal_fop_xdata (dict_t **xdata)
+{
+    dict_t *dict = NULL;
+
+    dict = dict_new();
+    if (!dict)
+       goto out;
+
+    if (dict_set_str (dict, GLUSTERFS_INTERNAL_FOP_KEY, "yes"))
+       goto out;
+
+    *xdata = dict;
+    return 0;
+out:
+    if (dict)
+            dict_unref (dict);
+    return -1;
+}
+
 void ec_writev_start(ec_fop_data_t *fop)
 {
     ec_t *ec = fop->xl->private;
@@ -1275,9 +1295,8 @@ void ec_writev_start(ec_fop_data_t *fop)
     fd_t *fd;
     size_t tail;
     uint64_t current;
-    uid_t uid;
-    gid_t gid;
     int32_t err = -ENOMEM;
+    dict_t      *xdata = NULL;
 
     /* This shouldn't fail because we have the inode locked. */
     GF_ASSERT(ec_get_inode_size(fop, fop->fd->inode, &current));
@@ -1289,9 +1308,7 @@ void ec_writev_start(ec_fop_data_t *fop)
         return;
     }
 
-    uid = fop->frame->root->uid;
     fop->frame->root->uid = 0;
-    gid = fop->frame->root->gid;
     fop->frame->root->gid = 0;
 
     ctx = ec_fd_get(fop->fd, fop->xl);
@@ -1330,24 +1347,31 @@ void ec_writev_start(ec_fop_data_t *fop)
     fop->buffers = iobref;
 
     if (fop->head > 0) {
+        if (ec_make_internal_fop_xdata (&xdata)) {
+                err = -ENOMEM;
+                goto out;
+        }
         ec_readv(fop->frame, fop->xl, -1, EC_MINIMUM_MIN, ec_writev_merge_head,
-                 NULL, fd, ec->stripe_size, fop->offset, 0, NULL);
+                 NULL, fd, ec->stripe_size, fop->offset, 0, xdata);
     }
     tail = fop->size - fop->user_size - fop->head;
     if ((tail > 0) && ((fop->head == 0) || (fop->size > ec->stripe_size))) {
         if (current > fop->offset + fop->head + fop->user_size) {
+            if (ec_make_internal_fop_xdata (&xdata)) {
+                    err = -ENOMEM;
+                    goto out;
+            }
             ec_readv(fop->frame, fop->xl, -1, EC_MINIMUM_MIN,
                      ec_writev_merge_tail, NULL, fd, ec->stripe_size,
-                     fop->offset + fop->size - ec->stripe_size, 0, NULL);
+                     fop->offset + fop->size - ec->stripe_size, 0, xdata);
         } else {
             memset(fop->vector[0].iov_base + fop->size - tail, 0, tail);
         }
     }
 
-    fop->frame->root->uid = uid;
-    fop->frame->root->gid = gid;
-
     fd_unref(fd);
+    if (xdata)
+            dict_unref (xdata);
 
     return;
 
@@ -1359,10 +1383,9 @@ out:
         iobref_unref(iobref);
     }
 
-    fop->frame->root->uid = uid;
-    fop->frame->root->gid = gid;
-
     fd_unref(fd);
+    if (xdata)
+            dict_unref (xdata);
 
     ec_fop_set_error(fop, -err);
 }
@@ -1460,6 +1483,11 @@ int32_t ec_manager_writev(ec_fop_data_t *fop, int32_t state)
             return EC_STATE_DELAYED_START;
 
         case EC_STATE_DELAYED_START:
+            /* Restore uid, gid if they were changed to do some partial
+             * reads. */
+            fop->frame->root->uid = fop->uid;
+            fop->frame->root->gid = fop->gid;
+
             ec_dispatch_all(fop);
 
             return EC_STATE_PREPARE_ANSWER;
@@ -1520,10 +1548,17 @@ int32_t ec_manager_writev(ec_fop_data_t *fop, int32_t state)
 
             return EC_STATE_LOCK_REUSE;
 
+        case -EC_STATE_DELAYED_START:
+            /* We have failed while doing partial reads. We need to restore
+             * original uid, gid. */
+            fop->frame->root->uid = fop->uid;
+            fop->frame->root->gid = fop->gid;
+
+        /* Fall through */
+
         case -EC_STATE_INIT:
         case -EC_STATE_LOCK:
         case -EC_STATE_DISPATCH:
-        case -EC_STATE_DELAYED_START:
         case -EC_STATE_PREPARE_ANSWER:
         case -EC_STATE_REPORT:
             GF_ASSERT(fop->error != 0);
-- 
1.7.1

