From 4beeb33a2c025a1f627225514b27056f1eb39ec4 Mon Sep 17 00:00:00 2001
From: Venky Shankar <vshankar@redhat.com>
Date: Wed, 30 Dec 2015 14:56:12 +0530
Subject: [PATCH 239/245] features/bitrot: add check for corrupted object in f{stat}

        Backport of http://review.gluster.org/13120

Check for corrupted objects is done bt bitrot stub component
for data operations and such fops are denied processing by
returning EIO. These checks were not done for operations such
as get/set extended attribute, stat and the likes - IOW, stub
only blocked pure data operations.

However, its necessary to have these checks for certain other
fops, most importantly stat (and fstat). This is due to the
fact that clients could possibly get stale stat information
(such as size, {a,c,m}time) resulting in incorrect operation
of the application that rely on these fields. Note that, the
data that replication would take care of fetching good (and
correct) data, but the staleness of stat information could
lead to data inconsistencies (e.g., rebalance, tier).

Change-Id: I5a22780373b182a13f8d2c4ca6b7d9aa0ffbfca3
BUG: 1297300
Signed-off-by: Venky Shankar <vshankar@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/65073
Reviewed-by: Rafi Kavungal Chundattu Parambil <rkavunga@redhat.com>
---
 tests/bugs/bitrot/bug-1288490.t                  |   48 ++++++++++++++++
 xlators/features/bit-rot/src/stub/bit-rot-stub.c |   63 +++++++++++-----------
 2 files changed, 79 insertions(+), 32 deletions(-)
 create mode 100644 tests/bugs/bitrot/bug-1288490.t

diff --git a/tests/bugs/bitrot/bug-1288490.t b/tests/bugs/bitrot/bug-1288490.t
new file mode 100644
index 0000000..5f67f4a
--- /dev/null
+++ b/tests/bugs/bitrot/bug-1288490.t
@@ -0,0 +1,48 @@
+#!/bin/bash
+
+. $(dirname $0)/../../include.rc
+. $(dirname $0)/../../volume.rc
+
+cleanup;
+
+TEST glusterd
+TEST pidof glusterd
+
+TEST $CLI volume create $V0 replica 2 $H0:$B0/brick{0,1}
+TEST $CLI volume start $V0
+
+TEST $CLI volume bitrot $V0 enable
+EXPECT_WITHIN $PROCESS_UP_TIMEOUT "1" get_bitd_count
+
+TEST $GFS --volfile-id=$V0 --volfile-server=$H0 $M0
+TEST dd if=/dev/urandom of=$M0/FILE bs=1024 count=1
+
+# corrupt data -- append 2 bytes
+echo -n "~~" >> $B0/brick0/FILE
+# manually set bad-file xattr
+TEST setfattr -n trusted.bit-rot.bad-file -v 0x3100 $B0/brick0/FILE
+
+TEST $CLI volume stop $V0
+TEST $CLI volume start $V0
+EXPECT 'Started' volinfo_field $V0 'Status';
+EXPECT_WITHIN $PROCESS_UP_TIMEOUT "1" brick_up_status $V0 $H0 $B0/brick0
+EXPECT_WITHIN $PROCESS_UP_TIMEOUT "1" brick_up_status $V0 $H0 $B0/brick1
+EXPECT_WITHIN $CHILD_UP_TIMEOUT "1" afr_child_up_status $V0 0
+EXPECT_WITHIN $CHILD_UP_TIMEOUT "1" afr_child_up_status $V0 1
+EXPECT_WITHIN $PROCESS_UP_TIMEOUT "1" get_bitd_count
+
+# trigger lookup
+TEST stat $M0/FILE
+
+# extend the file
+TEST dd if=/dev/urandom of=$M0/FILE bs=1024 count=1 oflag=append conv=notrunc
+
+# check backend file size
+EXPECT "1026" stat -c "%s" $B0/brick0/FILE
+EXPECT "2048" stat -c "%s" $B0/brick1/FILE
+
+# check file size on mount
+EXPECT "2048" stat -c "%s" $M0/FILE
+
+TEST umount $M0
+cleanup
diff --git a/xlators/features/bit-rot/src/stub/bit-rot-stub.c b/xlators/features/bit-rot/src/stub/bit-rot-stub.c
index 8fa0f6f..3afb9d7 100644
--- a/xlators/features/bit-rot/src/stub/bit-rot-stub.c
+++ b/xlators/features/bit-rot/src/stub/bit-rot-stub.c
@@ -2790,53 +2790,51 @@ br_stub_lookup (call_frame_t *frame,
 
 /** {{{ */
 
-/* fstat() */
-int br_stub_fstat_cbk (call_frame_t *frame, void *cookie, xlator_t *this,
-                       int32_t op_ret, int32_t op_errno, struct iatt *buf,
-                       dict_t *xdata)
+/* stat */
+int
+br_stub_stat (call_frame_t *frame, xlator_t *this, loc_t *loc, dict_t *xdata)
 {
+        int32_t ret      = 0;
+        int32_t op_ret   = -1;
+        int32_t op_errno = EINVAL;
 
-        int              ret    = 0;
-        br_stub_local_t *local  = NULL;
-        inode_t         *inode  = NULL;
+        if (!IA_ISREG (loc->inode->ia_type))
+                goto wind;
 
-        local = frame->local;
-        frame->local = NULL;
-        inode = local->u.context.inode;
+        ret = br_stub_check_bad_object (this, loc->inode, &op_ret, &op_errno);
+        if (ret)
+                goto unwind;
 
-        ret = br_stub_mark_xdata_bad_object (this, inode, xdata);
-        if (ret) {
-                op_ret = -1;
-                op_errno = EIO;
-        }
+ wind:
+        STACK_WIND_TAIL (frame, FIRST_CHILD(this),
+                         FIRST_CHILD(this)->fops->stat, loc, xdata);
+        return 0;
 
-        br_stub_cleanup_local(local);
-        br_stub_dealloc_local(local);
-        STACK_UNWIND_STRICT (fstat, frame, op_ret, op_errno, buf, xdata);
+unwind:
+        STACK_UNWIND_STRICT (stat, frame, op_ret, op_errno, NULL, NULL);
         return 0;
 }
 
+/* fstat */
 int
 br_stub_fstat (call_frame_t *frame, xlator_t *this, fd_t *fd, dict_t *xdata)
 {
-        br_stub_local_t *local    = NULL;
-        int32_t          op_ret   = -1;
-        int32_t          op_errno = EINVAL;
+        int32_t ret      = 0;
+        int32_t op_ret   = -1;
+        int32_t op_errno = EINVAL;
 
-        local = br_stub_alloc_local (this);
-        if (!local) {
-                op_ret = -1;
-                op_errno = ENOMEM;
-                goto unwind;
-        }
+        if (!IA_ISREG (fd->inode->ia_type))
+                goto wind;
 
-        br_stub_fill_local (local, NULL, fd, fd->inode, fd->inode->gfid,
-                            BR_STUB_NO_VERSIONING, 0);
-        frame->local = local;
+        ret = br_stub_check_bad_object (this, fd->inode, &op_ret, &op_errno);
+        if (ret)
+                goto unwind;
 
-        STACK_WIND (frame, br_stub_fstat_cbk, FIRST_CHILD(this),
-                    FIRST_CHILD(this)->fops->fstat, fd, xdata);
+ wind:
+        STACK_WIND_TAIL (frame, FIRST_CHILD(this),
+                         FIRST_CHILD(this)->fops->fstat, fd, xdata);
         return 0;
+
 unwind:
         STACK_UNWIND_STRICT (fstat, frame, op_ret, op_errno, NULL, NULL);
         return 0;
@@ -3120,6 +3118,7 @@ unblock:
 
 struct xlator_fops fops = {
         .lookup    = br_stub_lookup,
+        .stat      = br_stub_stat,
         .fstat     = br_stub_fstat,
         .open      = br_stub_open,
         .create    = br_stub_create,
-- 
1.7.1

