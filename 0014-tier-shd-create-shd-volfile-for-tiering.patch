From 168ab59ca402ab1011d9110a12000d066603532e Mon Sep 17 00:00:00 2001
From: Mohammed Rafi KC <rkavunga@redhat.com>
Date: Thu, 20 Aug 2015 12:19:51 +0530
Subject: [PATCH 14/23] tier/shd: create shd volfile for tiering

Currently shd graph will only start if it is replicate
or disperse volume. But in case of tiering, volume type
will be tier. So we need to start shd if any of the cold
or hot is compatible with shd volume.

Back port of>
>Change-Id: Ic689746ac7d2fc6a9eccdabd8518dc9139829de2
>BUG: 1261276
>Signed-off-by: Mohammed Rafi KC <rkavunga@redhat.com>
>Reviewed-on: http://review.gluster.org/11962
>Tested-by: Gluster Build System <jenkins@build.gluster.com>
>Tested-by: NetBSD Build System <jenkins@build.gluster.org>
>Reviewed-by: Pranith Kumar Karampuri <pkarampu@redhat.com>

>(cherry picked from commit fdff192b918ca9cd237f3f784c627102377e3661)

>Change-Id: I236a31e7dcefb3dad64881e0b007144bd826b840
>BUG: 1261744
>Signed-off-by: Mohammed Rafi KC <rkavunga@redhat.com>
>Reviewed-on: http://review.gluster.org/12333
>Tested-by: Gluster Build System <jenkins@build.gluster.com>
>Tested-by: NetBSD Build System <jenkins@build.gluster.org>
>Reviewed-by: Dan Lambright <dlambrig@redhat.com>
>Tested-by: Dan Lambright <dlambrig@redhat.com>

Change-Id: I23e53a5f89b72f26fc6b8ef2bbca9aa8d7073c7d
BUG: 1271733
Signed-off-by: Mohammed Rafi KC <rkavunga@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/59403
Reviewed-by: Dan Lambright <dlambrig@redhat.com>
Tested-by: Dan Lambright <dlambrig@redhat.com>
---
 xlators/mgmt/glusterd/src/glusterd-utils.c  |   98 +++++++++++++++-
 xlators/mgmt/glusterd/src/glusterd-utils.h  |    7 +
 xlators/mgmt/glusterd/src/glusterd-volgen.c |  177 ++++++++++++++++++++++++---
 3 files changed, 262 insertions(+), 20 deletions(-)

diff --git a/xlators/mgmt/glusterd/src/glusterd-utils.c b/xlators/mgmt/glusterd/src/glusterd-utils.c
index cde6ad1..1994e74 100644
--- a/xlators/mgmt/glusterd/src/glusterd-utils.c
+++ b/xlators/mgmt/glusterd/src/glusterd-utils.c
@@ -630,6 +630,84 @@ glusterd_brickinfo_dup (glusterd_brickinfo_t *brickinfo,
 out:
         return ret;
 }
+int32_t
+glusterd_create_sub_tier_volinfo (glusterd_volinfo_t *volinfo,
+                                  glusterd_volinfo_t **dup_volinfo,
+                                  gf_boolean_t is_hot_tier,
+                                  const char *new_volname)
+{
+        glusterd_brickinfo_t *brickinfo       = NULL;
+        glusterd_brickinfo_t *brickinfo_dup   = NULL;
+        gd_tier_info_t       *tier_info       = NULL;
+        int                   i               = 0;
+        int                   ret             = -1;
+
+        tier_info = &(volinfo->tier_info);
+
+        ret = glusterd_volinfo_dup (volinfo, dup_volinfo, _gf_true);
+        if (ret) {
+                gf_msg ("glusterd", GF_LOG_ERROR, 0, GD_MSG_VOL_OP_FAILED,
+                        "Failed to create volinfo");
+                return ret;
+        }
+
+        (*dup_volinfo)->is_snap_volume   = volinfo->is_snap_volume;
+        (*dup_volinfo)->status           = volinfo->status;
+        memcpy (&(*dup_volinfo)->tier_info, &volinfo->tier_info,
+                sizeof (volinfo->tier_info));
+
+        strcpy ((*dup_volinfo)->volname, new_volname);
+
+        cds_list_for_each_entry (brickinfo, &volinfo->bricks, brick_list) {
+                i++;
+
+                if (is_hot_tier) {
+                        if (i > volinfo->tier_info.hot_brick_count)
+                                break;
+                } else {
+                        if (i <= volinfo->tier_info.hot_brick_count)
+                                continue;
+                }
+
+                ret = glusterd_brickinfo_new (&brickinfo_dup);
+                if (ret) {
+                        gf_msg ("glusterd", GF_LOG_ERROR, 0,
+                                GD_MSG_BRICK_NEW_INFO_FAIL, "Failed to create "
+                                "new brickinfo");
+                        goto out;
+                }
+
+
+                glusterd_brickinfo_dup (brickinfo, brickinfo_dup);
+                cds_list_add_tail (&brickinfo_dup->brick_list,
+                              &((*dup_volinfo)->bricks));
+        }
+
+        if (is_hot_tier) {
+            (*dup_volinfo)->type             = tier_info->hot_type;
+            (*dup_volinfo)->replica_count    = tier_info->hot_replica_count;
+            (*dup_volinfo)->brick_count      = tier_info->hot_brick_count;
+            (*dup_volinfo)->dist_leaf_count  =
+                                   glusterd_get_dist_leaf_count(*dup_volinfo);
+
+        } else {
+            (*dup_volinfo)->type             = tier_info->cold_type;
+            (*dup_volinfo)->replica_count    = tier_info->cold_replica_count;
+            (*dup_volinfo)->disperse_count   = tier_info->cold_disperse_count;
+            (*dup_volinfo)->redundancy_count = tier_info->cold_redundancy_count;
+            (*dup_volinfo)->dist_leaf_count  = tier_info->cold_dist_leaf_count;
+            (*dup_volinfo)->brick_count      = tier_info->cold_brick_count;
+        }
+out:
+        if (ret && *dup_volinfo) {
+                glusterd_volinfo_delete (*dup_volinfo);
+                *dup_volinfo = NULL;
+        }
+
+        return ret;
+
+}
+
 /*
  * gd_vol_is_geo_rep_active:
  *      This function checks for any running geo-rep session for
@@ -6305,9 +6383,9 @@ glusterd_is_volume_replicate (glusterd_volinfo_t *volinfo)
 }
 
 gf_boolean_t
-glusterd_is_shd_compatible_volume (glusterd_volinfo_t *volinfo)
+glusterd_is_shd_compatible_type (int type)
 {
-        switch (volinfo->type) {
+        switch (type) {
         case GF_CLUSTER_TYPE_REPLICATE:
         case GF_CLUSTER_TYPE_STRIPE_REPLICATE:
         case GF_CLUSTER_TYPE_DISPERSE:
@@ -6317,6 +6395,22 @@ glusterd_is_shd_compatible_volume (glusterd_volinfo_t *volinfo)
         return _gf_false;
 }
 
+gf_boolean_t
+glusterd_is_shd_compatible_volume (glusterd_volinfo_t *volinfo)
+{
+
+        int     ret     = 0;
+
+        if (volinfo->type == GF_CLUSTER_TYPE_TIER) {
+                ret = glusterd_is_shd_compatible_type
+                                         (volinfo->tier_info.cold_type) |
+                      glusterd_is_shd_compatible_type
+                                         (volinfo->tier_info.hot_type);
+                return ret;
+        }
+        return glusterd_is_shd_compatible_type (volinfo->type);
+}
+
 int
 glusterd_set_dump_options (char *dumpoptions_path, char *options,
                            int option_cnt)
diff --git a/xlators/mgmt/glusterd/src/glusterd-utils.h b/xlators/mgmt/glusterd/src/glusterd-utils.h
index a0fb7a5..02d2620 100644
--- a/xlators/mgmt/glusterd/src/glusterd-utils.h
+++ b/xlators/mgmt/glusterd/src/glusterd-utils.h
@@ -366,6 +366,11 @@ glusterd_get_trusted_client_filepath (char *filepath,
 int
 glusterd_restart_rebalance (glusterd_conf_t *conf);
 
+int32_t
+glusterd_create_sub_tier_volinfo (glusterd_volinfo_t *volinfo,
+                                   glusterd_volinfo_t **dup_volinfo,
+                                   gf_boolean_t is_hot_tier,
+                                   const char *new_name);
 void
 glusterd_restart_rebalance_for_volume (glusterd_volinfo_t *volinfo);
 
@@ -643,6 +648,8 @@ glusterd_import_quota_conf (dict_t *peer_data, int vol_idx,
 gf_boolean_t
 glusterd_is_shd_compatible_volume (glusterd_volinfo_t *volinfo);
 
+inline gf_boolean_t
+glusterd_is_shd_compatible_type (int type);
 
 gf_boolean_t
 glusterd_are_all_volumes_stopped ();
diff --git a/xlators/mgmt/glusterd/src/glusterd-volgen.c b/xlators/mgmt/glusterd/src/glusterd-volgen.c
index 2b4ca74..d531ad3 100644
--- a/xlators/mgmt/glusterd/src/glusterd-volgen.c
+++ b/xlators/mgmt/glusterd/src/glusterd-volgen.c
@@ -2829,6 +2829,57 @@ out:
 }
 
 static int
+volgen_graph_build_clients_for_tier_shd (volgen_graph_t *graph,
+                            glusterd_volinfo_t *volinfo,
+                            dict_t *set_dict)
+{
+        int                     ret             = 0;
+        glusterd_volinfo_t     *dup_volinfo     = NULL;
+        gf_boolean_t            is_hot_tier     = _gf_false;
+        gf_boolean_t            is_hot_shd      = _gf_false;
+        gf_boolean_t            is_cold_shd     = _gf_false;
+
+        is_cold_shd = glusterd_is_shd_compatible_type
+                              (volinfo->tier_info.cold_type);
+        is_hot_shd = glusterd_is_shd_compatible_type
+                              (volinfo->tier_info.hot_type);
+
+        if (is_cold_shd && is_hot_shd) {
+                ret = volgen_graph_build_clients (graph, volinfo,
+                                                  set_dict, NULL);
+                return ret;
+        }
+
+        if (is_cold_shd) {
+                ret = glusterd_create_sub_tier_volinfo (volinfo, &dup_volinfo,
+                                                        is_hot_tier,
+                                                        volinfo->volname);
+                if (ret)
+                        goto out;
+                ret = volgen_graph_build_clients (graph, dup_volinfo,
+                                                  set_dict, NULL);
+                if (ret)
+                        goto out;
+        }
+        if (is_hot_shd) {
+                is_hot_tier = _gf_true;
+                ret = glusterd_create_sub_tier_volinfo (volinfo, &dup_volinfo,
+                                                        is_hot_tier,
+                                                        volinfo->volname);
+                if (ret)
+                        goto out;
+                ret = volgen_graph_build_clients (graph, dup_volinfo,
+                                                  set_dict, NULL);
+                if (ret)
+                        goto out;
+       }
+out:
+        if (dup_volinfo)
+                glusterd_volinfo_delete (dup_volinfo);
+        return ret;
+}
+
+static int
 volgen_link_bricks (volgen_graph_t *graph,
                     glusterd_volinfo_t *volinfo, char *xl_type,
                     char *xl_namefmt, size_t child_count,
@@ -2865,7 +2916,7 @@ volgen_link_bricks (volgen_graph_t *graph,
                         break;
         }
 
-        ret = j;
+        ret = j - start_count;
 out:
         return ret;
 }
@@ -3241,16 +3292,25 @@ volgen_graph_build_afr_clusters (volgen_graph_t *graph,
         char            option[32]           = {0};
         int             start_count = 0;
 
-        if (volinfo->tier_info.cur_tier_hot &&
-            volinfo->tier_info.cold_type == GF_CLUSTER_TYPE_REPLICATE)
+        if (volinfo->tier_info.cold_type == GF_CLUSTER_TYPE_REPLICATE)
                 start_count = volinfo->tier_info.cold_brick_count /
                               volinfo->tier_info.cold_replica_count;
-        clusters = volgen_link_bricks_from_list_tail_start (graph, volinfo,
+        if (volinfo->tier_info.cur_tier_hot)
+                clusters = volgen_link_bricks_from_list_head_start (graph,
+                                                volinfo,
                                                 replicate_args[0],
                                                 replicate_args[1],
                                                 volinfo->brick_count,
                                                 volinfo->replica_count,
                                                 start_count);
+        else
+                clusters = volgen_link_bricks_from_list_tail (graph,
+                                                volinfo,
+                                                replicate_args[0],
+                                                replicate_args[1],
+                                                volinfo->brick_count,
+                                                volinfo->replica_count);
+
         if (clusters < 0)
                 goto out;
 
@@ -3477,6 +3537,7 @@ volume_volgen_graph_build_clusters_tier (volgen_graph_t *graph,
         int                st_dist_leaf_count = 0;
         int                st_type = 0;
         int                dist_count = 0;
+        int                start_count = 0;
         char              *decommissioned_children = NULL;
 
         st_brick_count     = volinfo->brick_count;
@@ -3507,6 +3568,10 @@ volume_volgen_graph_build_clusters_tier (volgen_graph_t *graph,
 
         dist_count = volinfo->brick_count / volinfo->dist_leaf_count;
 
+        if (volinfo->tier_info.cold_type == GF_CLUSTER_TYPE_REPLICATE) {
+                start_count = volinfo->tier_info.cold_brick_count /
+                              volinfo->tier_info.cold_replica_count;
+        }
         if (volinfo->dist_leaf_count != 1) {
                 ret = volgen_link_bricks_from_list_head_start
                         (graph, volinfo,
@@ -3514,8 +3579,7 @@ volume_volgen_graph_build_clusters_tier (volgen_graph_t *graph,
                          "%s-replicate-%d",
                          volinfo->brick_count,
                          volinfo->replica_count,
-                         volinfo->tier_info.cold_brick_count/
-                         volinfo->tier_info.cold_replica_count);
+                         start_count);
                 if (ret != -1)
                         volgen_link_bricks_from_list_tail (graph,  volinfo,
                                                            "cluster/distribute",
@@ -4175,6 +4239,9 @@ volgen_get_shd_key (glusterd_volinfo_t *volinfo)
         case GF_CLUSTER_TYPE_DISPERSE:
                 key = "cluster.disperse-self-heal-daemon";
                 break;
+        case GF_CLUSTER_TYPE_TIER:
+                key = "cluster.tier-self-heal-daemon";
+                break;
         default:
                 key = NULL;
                 break;
@@ -4240,16 +4307,10 @@ out:
 }
 
 static int
-build_shd_clusters (volgen_graph_t *graph, glusterd_volinfo_t *volinfo,
-                    dict_t *set_dict)
+build_afr_ec_clusters (volgen_graph_t *graph, glusterd_volinfo_t *volinfo)
 {
-        int     ret = 0;
-        int     clusters = -1;
-
-        ret = volgen_graph_build_clients (graph, volinfo, set_dict, NULL);
-        if (ret)
-                goto out;
 
+        int clusters = -1;
         switch (volinfo->type) {
         case GF_CLUSTER_TYPE_REPLICATE:
         case GF_CLUSTER_TYPE_STRIPE_REPLICATE:
@@ -4260,6 +4321,86 @@ build_shd_clusters (volgen_graph_t *graph, glusterd_volinfo_t *volinfo,
                 clusters = volgen_graph_build_ec_clusters (graph, volinfo);
                 break;
         }
+        return clusters;
+}
+
+static int
+build_afr_ec_clusters_for_tier (volgen_graph_t *graph,
+                                 glusterd_volinfo_t *volinfo,
+                                 dict_t *set_dict)
+{
+        int                     ret                 = 0;
+        glusterd_volinfo_t      *dup_volinfo[2]     = {NULL, NULL};
+        int                     clusters            = 0;
+        int                     i                   = 0;
+        volgen_graph_t          hot_graph           = {0};
+        volgen_graph_t          cold_cgraph         = {0};
+        gf_boolean_t            is_hot_tier         = _gf_false;
+
+        if (glusterd_is_shd_compatible_type (volinfo->tier_info.cold_type)) {
+                ret = glusterd_create_sub_tier_volinfo (volinfo,
+                                                        &dup_volinfo[0],
+                                                        is_hot_tier,
+                                                        volinfo->volname);
+                if (ret)
+                        goto out;
+        }
+        if (glusterd_is_shd_compatible_type (volinfo->tier_info.hot_type)) {
+                is_hot_tier = _gf_true;
+                ret = glusterd_create_sub_tier_volinfo (volinfo,
+                                                        &dup_volinfo[1],
+                                                        is_hot_tier,
+                                                        volinfo->volname);
+                if (ret)
+                        goto out;
+                dup_volinfo[1]->tier_info.cur_tier_hot = 1;
+        }
+
+        for (i = 0; i < 2; i++) {
+                if (!dup_volinfo[i])
+                        continue;
+                ret = build_afr_ec_clusters (graph, dup_volinfo[i]);
+                if (ret < 0)
+                        goto out;
+                clusters += ret;
+        }
+        ret = 0;
+out:
+        for (i = 0; i < 2; i++) {
+                if (dup_volinfo[i])
+                        glusterd_volinfo_delete (dup_volinfo[i]);
+        }
+
+        if (ret)
+                clusters = -1;
+
+        return clusters;
+}
+
+
+
+static int
+build_shd_clusters (volgen_graph_t *graph, glusterd_volinfo_t *volinfo,
+                    dict_t *set_dict)
+{
+        int     ret = 0;
+        int     clusters = -1;
+
+        if (volinfo->type == GF_CLUSTER_TYPE_TIER) {
+                ret = volgen_graph_build_clients_for_tier_shd (graph, volinfo,
+                                                               set_dict);
+                if (ret)
+                        goto out;
+
+                clusters = build_afr_ec_clusters_for_tier (graph, volinfo,
+                                                           set_dict);
+        } else {
+                ret = volgen_graph_build_clients (graph, volinfo,
+                                                  set_dict, NULL);
+                if (ret)
+                        goto out;
+                clusters = build_afr_ec_clusters (graph, volinfo);
+        }
 out:
         return clusters;
 }
@@ -4413,14 +4554,14 @@ build_shd_graph (volgen_graph_t *graph, dict_t *mod_dict)
         }
 
         cds_list_for_each_entry (voliter, &priv->volumes, vol_list) {
-                ret = build_shd_volume_graph (this, graph, voliter, mod_dict,
-                                              set_dict, graph_check,
-                                              &valid_config);
-
+                ret = build_shd_volume_graph (this, graph, voliter,
+                                              mod_dict, set_dict,
+                                              graph_check, &valid_config);
                 ret = dict_reset (set_dict);
                 if (ret)
                         goto out;
         }
+
 out:
         if (set_dict)
                 dict_unref (set_dict);
-- 
1.7.1

