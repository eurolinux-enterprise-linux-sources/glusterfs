From 4534876ce40f48c2a6ca43c3c7aab83027631461 Mon Sep 17 00:00:00 2001
From: Aravinda VK <avishwan@redhat.com>
Date: Thu, 16 Jul 2015 17:05:25 +0530
Subject: [PATCH 122/131] tools/glusterfind: Handle Keyboard interrupt

Do not print Python traceback when glusterfind command is interrupted

Change-Id: I67383534f965e410fef7ce09798e9d435ef738ae
Signed-off-by: Aravinda VK <avishwan@redhat.com>
BUG: 1228079
Reviewed-on: http://review.gluster.org/11698
Reviewed-on: http://review.gluster.org/12649
Tested-by: NetBSD Build System <jenkins@build.gluster.org>
Tested-by: Gluster Build System <jenkins@build.gluster.com>
Reviewed-by: Milind Changire <mchangir@redhat.com>
Reviewed-by: Saravanakumar Arumugam <sarumuga@redhat.com>
Reviewed-by: Venky Shankar <vshankar@redhat.com>
Reviewed-on: https://code.engineering.redhat.com/gerrit/61973
---
 tools/glusterfind/src/main.py |   96 ++++++++++++++++++++++------------------
 1 files changed, 53 insertions(+), 43 deletions(-)

diff --git a/tools/glusterfind/src/main.py b/tools/glusterfind/src/main.py
index 6c2568e..4e574ea 100644
--- a/tools/glusterfind/src/main.py
+++ b/tools/glusterfind/src/main.py
@@ -53,31 +53,34 @@ def node_cmd(host, host_uuid, task, cmd, args, opts):
     """
     Runs command via ssh if host is not local
     """
-    localdir = is_host_local(host_uuid)
+    try:
+        localdir = is_host_local(host_uuid)
 
-    # this is so to avoid deleting the ssh keys on local node which otherwise
-    # cause ssh password prompts on the console (race conditions)
-    # mode_delete() should be cleaning up the session tree
-    if localdir and task == "delete":
-        return
+        # this is so to avoid deleting the ssh keys on local node which
+        # otherwise cause ssh password prompts on the console (race conditions)
+        # mode_delete() should be cleaning up the session tree
+        if localdir and task == "delete":
+            return
 
-    pem_key_path = get_pem_key_path(args.session, args.volume)
+        pem_key_path = get_pem_key_path(args.session, args.volume)
 
-    if not localdir:
-        # prefix with ssh command if not local node
-        cmd = ["ssh",
-               "-i", pem_key_path,
-               "root@%s" % host] + cmd
+        if not localdir:
+            # prefix with ssh command if not local node
+            cmd = ["ssh",
+                   "-i", pem_key_path,
+                   "root@%s" % host] + cmd
 
-    execute(cmd, exit_msg="%s - %s failed" % (host, task), logger=logger)
+        execute(cmd, exit_msg="%s - %s failed" % (host, task), logger=logger)
 
-    if opts.get("copy_outfile", False):
-        cmd_copy = ["scp",
-                    "-i", pem_key_path,
-                    "root@%s:/%s" % (host, opts.get("node_outfile")),
-                    os.path.dirname(opts.get("node_outfile"))]
-        execute(cmd_copy, exit_msg="%s - Copy command failed" % host,
-                logger=logger)
+        if opts.get("copy_outfile", False):
+            cmd_copy = ["scp",
+                        "-i", pem_key_path,
+                        "root@%s:/%s" % (host, opts.get("node_outfile")),
+                        os.path.dirname(opts.get("node_outfile"))]
+            execute(cmd_copy, exit_msg="%s - Copy command failed" % host,
+                    logger=logger)
+    except KeyboardInterrupt:
+        sys.exit(2)
 
 
 def run_cmd_nodes(task, args, **kwargs):
@@ -555,31 +558,38 @@ def mode_list(session_dir, args):
 
 
 def main():
-    args = _get_args()
-    mkdirp(conf.get_opt("session_dir"), exit_on_err=True)
+    try:
+        args = _get_args()
+        mkdirp(conf.get_opt("session_dir"), exit_on_err=True)
 
-    if args.mode == "list":
-        session_dir = conf.get_opt("session_dir")
-    else:
-        session_dir = os.path.join(conf.get_opt("session_dir"),
-                                   args.session)
+        if args.mode == "list":
+            session_dir = conf.get_opt("session_dir")
+        else:
+            session_dir = os.path.join(conf.get_opt("session_dir"),
+                                       args.session)
 
-    if not os.path.exists(session_dir) and args.mode not in ["create", "list"]:
-        fail("Invalid session %s" % args.session)
+        if not os.path.exists(session_dir) and args.mode not in ["create",
+                                                                 "list"]:
+            fail("Invalid session %s" % args.session)
 
-    vol_dir = os.path.join(session_dir, args.volume)
-    if not os.path.exists(vol_dir) and args.mode not in ["create", "list"]:
-        fail("Session %s not created with volume %s" %
-             (args.session, args.volume))
+        vol_dir = os.path.join(session_dir, args.volume)
+        if not os.path.exists(vol_dir) and args.mode not in ["create", "list"]:
+            fail("Session %s not created with volume %s" %
+                 (args.session, args.volume))
 
-    mkdirp(os.path.join(conf.get_opt("log_dir"), args.session, args.volume),
-           exit_on_err=True)
-    log_file = os.path.join(conf.get_opt("log_dir"),
+        mkdirp(os.path.join(conf.get_opt("log_dir"),
                             args.session,
-                            args.volume,
-                            "cli.log")
-    setup_logger(logger, log_file, args.debug)
-
-    # globals() will have all the functions already defined.
-    # mode_<args.mode> will be the function name to be called
-    globals()["mode_" + args.mode](session_dir, args)
+                            args.volume),
+               exit_on_err=True)
+        log_file = os.path.join(conf.get_opt("log_dir"),
+                                args.session,
+                                args.volume,
+                                "cli.log")
+        setup_logger(logger, log_file, args.debug)
+
+        # globals() will have all the functions already defined.
+        # mode_<args.mode> will be the function name to be called
+        globals()["mode_" + args.mode](session_dir, args)
+    except KeyboardInterrupt:
+        # Interrupted, exit with non zero error code
+        sys.exit(2)
-- 
1.7.1

